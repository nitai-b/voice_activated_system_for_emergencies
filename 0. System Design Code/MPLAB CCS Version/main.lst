CCS PCH C Compiler, Version 5.059, 5967               29-Mar-17 10:46

               Filename:   C:\Users\nitai\OneDrive\Documents\Year 3- ECNG 3020- Special Project\2. Designs\0. System Design Code\MPLAB CCS Version\main.lst

               ROM used:   3604 bytes (6%)
                           Largest free fragment is 61096
               RAM used:   123 (3%) at main() level
                           136 (3%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 30

*
0000:  GOTO   0D52
*
0008:  GOTO   00B2
000C:  NOP   
000E:  NOP   
0010:  NOP   
0012:  NOP   
0014:  NOP   
0016:  NOP   
0018:  MOVWF  04
001A:  MOVFF  FD8,05
001E:  MOVFF  FE0,06
0022:  MOVLB  0
0024:  MOVFF  FE9,0C
0028:  MOVFF  FEA,07
002C:  MOVFF  FE1,08
0030:  MOVFF  FE2,09
0034:  MOVFF  FD9,0A
0038:  MOVFF  FDA,0B
003C:  MOVFF  FF3,12
0040:  MOVFF  FF4,13
0044:  MOVFF  FFA,14
0048:  MOVFF  FF5,15
004C:  MOVFF  FF6,16
0050:  MOVFF  FF7,17
0054:  MOVFF  00,0E
0058:  MOVFF  01,0F
005C:  MOVFF  02,10
0060:  MOVFF  03,11
0064:  MOVFF  0E,00
0068:  MOVFF  0F,01
006C:  MOVFF  10,02
0070:  MOVFF  11,03
0074:  MOVFF  0C,FE9
0078:  MOVFF  07,FEA
007C:  BSF    07.7
007E:  MOVFF  08,FE1
0082:  MOVFF  09,FE2
0086:  MOVFF  0A,FD9
008A:  MOVFF  0B,FDA
008E:  MOVFF  12,FF3
0092:  MOVFF  13,FF4
0096:  MOVFF  14,FFA
009A:  MOVFF  15,FF5
009E:  MOVFF  16,FF6
00A2:  MOVFF  17,FF7
00A6:  MOVF   04,W
00A8:  MOVFF  06,FE0
00AC:  MOVFF  05,FD8
00B0:  RETFIE 0
00B2:  MOVWF  19
00B4:  MOVFF  FD8,1A
00B8:  MOVFF  FE0,1B
00BC:  MOVLB  0
00BE:  MOVFF  FE9,21
00C2:  MOVFF  FEA,1C
00C6:  MOVFF  FE1,1D
00CA:  MOVFF  FE2,1E
00CE:  MOVFF  FD9,1F
00D2:  MOVFF  FDA,20
00D6:  MOVFF  FF3,27
00DA:  MOVFF  FF4,28
00DE:  MOVFF  FFA,29
00E2:  MOVFF  FF5,2A
00E6:  MOVFF  FF6,2B
00EA:  MOVFF  FF7,2C
00EE:  MOVFF  00,23
00F2:  MOVFF  01,24
00F6:  MOVFF  02,25
00FA:  MOVFF  03,26
00FE:  BTFSS  FF2.4
0100:  GOTO   010A
0104:  BTFSC  FF2.1
0106:  GOTO   01E4
010A:  MOVFF  23,00
010E:  MOVFF  24,01
0112:  MOVFF  25,02
0116:  MOVFF  26,03
011A:  MOVFF  21,FE9
011E:  MOVFF  1C,FEA
0122:  BSF    1C.7
0124:  MOVFF  1D,FE1
0128:  MOVFF  1E,FE2
012C:  MOVFF  1F,FD9
0130:  MOVFF  20,FDA
0134:  MOVFF  27,FF3
0138:  MOVFF  28,FF4
013C:  MOVFF  29,FFA
0140:  MOVFF  2A,FF5
0144:  MOVFF  2B,FF6
0148:  MOVFF  2C,FF7
014C:  MOVF   19,W
014E:  MOVFF  1B,FE0
0152:  MOVFF  1A,FD8
0156:  RETFIE 0
.................... //                    =======================                    // 
.................... //====================I N T R O D U C T I O N====================// 
.................... //                    =======================                    // 
.................... /*		 
....................  *		Author:		Mr. Nitai Barran 
....................  *		Supervisor: Prof. Stephan J.G. Gift 
....................  *		System:		Voice Activated System for Emergencies 
....................  */ 
.................... #include <18f4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
0158:  DATA 41,6E
015A:  DATA 73,77
015C:  DATA 65,72
015E:  DATA 69,6E
0160:  DATA 67,2E
0162:  DATA 2E,2E
0164:  DATA 00,00
0166:  DATA 41,54
0168:  DATA 44,2B
016A:  DATA 31,38
016C:  DATA 36,38
016E:  DATA 36,38
0170:  DATA 32,32
0172:  DATA 30,31
0174:  DATA 35,3B
0176:  DATA 0D,0A
0178:  DATA 00,00
017A:  DATA 43,61
017C:  DATA 6C,6C
017E:  DATA 69,6E
0180:  DATA 67,2E
0182:  DATA 2E,2E
0184:  DATA 00,00
0186:  DATA 45,6E
0188:  DATA 64,69
018A:  DATA 6E,67
018C:  DATA 2E,2E
018E:  DATA 2E,00
0190:  DATA 79,6F
0192:  DATA 75,20
0194:  DATA 73,61
0196:  DATA 69,64
0198:  DATA 20,68
019A:  DATA 65,6C
019C:  DATA 6C,6F
019E:  DATA 00,00
*
0824:  ADDWF  FE8,W
0826:  CLRF   FF7
0828:  RLCF   FF7,F
082A:  ADDLW  3F
082C:  MOVWF  FF6
082E:  MOVLW  08
0830:  ADDWFC FF7,F
0832:  TBLRD*-
0834:  MOVF   FF5,W
0836:  MOVWF  FFA
0838:  TBLRD*
083A:  MOVF   FF5,W
083C:  MOVWF  FF9
083E:  DATA 76,03
0840:  DATA A4,03
0842:  DATA D2,03
0844:  DATA 00,04
0846:  DATA 2E,04
0848:  DATA 5C,04
084A:  DATA 8A,04
084C:  DATA B8,04
084E:  DATA E6,04
0850:  DATA 14,05
0852:  DATA 42,05
0854:  DATA 70,05
0856:  DATA 9E,05
0858:  DATA CC,05
085A:  DATA FA,05
085C:  DATA 28,06
085E:  DATA 56,06
0860:  DATA 84,06
0862:  DATA B2,06
0864:  DATA E0,06
0866:  DATA 0E,07
0868:  DATA 3C,07
086A:  DATA 6A,07
086C:  DATA 98,07
086E:  DATA C6,07
0870:  DATA F4,07
0872:  TBLRD*+
0874:  MOVF   FF5,F
0876:  BZ    0890
0878:  MOVFF  FF6,7D
087C:  MOVFF  FF7,7E
0880:  MOVFF  FF5,7F
0884:  RCALL  0252
0886:  MOVFF  7D,FF6
088A:  MOVFF  7E,FF7
088E:  BRA    0872
0890:  GOTO   091A (RETURN)
*
0AB2:  MOVF   FEF,F
0AB4:  BZ    0AD4
0AB6:  MOVFF  FEA,7E
0ABA:  MOVFF  FE9,7D
0ABE:  MOVFF  FEF,7F
0AC2:  BRA    0A70
0AC4:  MOVFF  7E,FEA
0AC8:  MOVFF  7D,FE9
0ACC:  INCF   FE9,F
0ACE:  BTFSC  FD8.2
0AD0:  INCF   FEA,F
0AD2:  BRA    0AB2
0AD4:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <protocol.h> 
.................... #ifndef PROTOCOL_H 
.................... #define PROTOCOL_H 
....................  
....................  
.................... #define NUL				0x00 //to initialise the received variable 
.................... #define CMD_BREAK		'b' // abort recog or ping 
.................... #define CMD_SLEEP       's' // go to power down 
.................... #define CMD_KNOB        'k' // set si knob <1> 
.................... #define CMD_MIC_DIST    'k' // set microphone (<1>=-1) distance <2> 
.................... #define CMD_LEVEL       'v' // set sd level <1> 
.................... #define CMD_VERIFY_RP   'v' // verify filesystem (<1>=-1) with flags <2> (0=check only, 1=fix) 
.................... #define CMD_LANGUAGE    'l' // set si language <1> 
.................... #define CMD_LIPSYNC     'l' // start real-time lipsync (<1>=-1) with threshold <2-3>, timeout <4-5> 
.................... #define CMD_TIMEOUT     'o' // set timeout <1> 
.................... #define CMD_RECOG_SI    'i' // do si recog from ws <1> 
.................... #define CMD_TRAIN_SD    't' // train sd command at group <1> pos <2> 
.................... #define CMD_TRAILING    't' // set trailing (<1>=-1) silence <2> (0-31 = 100-875 milliseconds) 
.................... #define CMD_GROUP_SD    'g' // insert new command at group <1> pos <2> 
.................... #define CMD_UNGROUP_SD  'u' // remove command at group <1> pos <2> 
.................... #define CMD_RECOG_SD    'd' // do sd recog at group <1> (0 = trigger mixed si/sd) 
.................... #define CMD_DUMP_RP     'd' // dump message (<1>=-1) at pos <2> 
.................... #define CMD_ERASE_SD    'e' // reset command at group <1> pos <2> 
.................... #define CMD_ERASE_RP    'e' // erase recording (<1>=-1) at pos <2> 
.................... #define CMD_NAME_SD     'n' // label command at group <1> pos <2> with length <3> name <4-n> 
.................... #define CMD_COUNT_SD    'c' // get command count for group <1> 
.................... #define CMD_DUMP_SD     'p' // read command data at group <1> pos <2> 
.................... #define CMD_PLAY_RP     'p' // play recording (<1>=-1) at pos <2> with flags <3> 
.................... #define CMD_MASK_SD     'm' // get active group mask 
.................... #define CMD_RESETALL    'r' // reset all memory (commands/groups and messages), with <1>='R' 
.................... #define CMD_RESET_SD    'r' // reset only commands/groups, with <1>='D' 
.................... #define CMD_RESET_RP    'r' // reset only messages, with <1>='M' 
.................... #define CMD_RECORD_RP   'r' // record message (<1>=-1) at pos <2> with bits <3> and timeout <4> 
.................... #define CMD_ID          'x' // get version id 
.................... #define CMD_DELAY       'y' // set transmit delay <1> (log scale) 
.................... #define CMD_BAUDRATE    'a' // set baudrate <1> (bit time, 1=>115200) 
.................... #define CMD_QUERY_IO    'q' // configure, read or write I/O pin <1> of type <2> 
.................... #define CMD_PLAY_SX     'w' // wave table entry <1-2> (10-bit) playback at volume <3> 
.................... #define CMD_PLAY_DTMF   'w' // play (<1>=-1) dial tone <2> for duration <3> 
.................... #define CMD_DUMP_SX     'h' // dump wave table entries 
.................... #define CMD_DUMP_SI     'z' // dump si settings for ws <1> (or total ws count if -1) 
.................... #define CMD_SEND_SN     'j' // send sonicnet token with bits <1> index <2-3> at time <4-5> 
.................... #define CMD_RECV_SN     'f' // receive sonicnet token with bits <1> rejection <2> timeout <3-4> 
.................... #define CMD_FAST_SD     'f' // set sd/sv (<1>=-1) to use fast recognition <2> (0=normal/default, 1=fast) 
....................  
.................... #define CMD_SERVICE     '~' // send service request 
.................... #define SVC_EXPORT_SD   'X' // request export of command <2> in group <1> as raw dump 
.................... #define SVC_IMPORT_SD   'I' // request import of command <2> in group <1> as raw dump 
.................... #define SVC_VERIFY_SD   'V' // verify training of imported raw command <2> in group <1> 
....................  
.................... #define STS_SERVICE     '~' // get service reply 
.................... #define SVC_DUMP_SD     'D' // provide raw command data <1-512> followed by checksum <513-516> 
....................  
.................... #define STS_MASK        'k' // mask of active groups <1-8> 
.................... #define STS_COUNT       'c' // count of commands <1> (or number of ws <1>) 
.................... #define STS_AWAKEN      'w' // back from power down mode 
.................... #define STS_DATA        'd' // provide training <1>, conflict <2>, command label <3-35> (counted string) 
.................... #define STS_ERROR       'e' // signal error code <1-2> 
.................... #define STS_INVALID     'v' // invalid command or argument 
.................... #define STS_TIMEOUT     't' // timeout expired 
.................... #define STS_LIPSYNC     'l' // lipsync stream follows 
.................... #define STS_INTERR      'i' // back from aborted recognition (see 'break') 
.................... #define STS_SUCCESS     'o' // no errors status 
.................... #define STS_RESULT      'r' // recognised sd command <1> - training similar to sd <1> 
.................... #define STS_SIMILAR     's' // recognised si <1> (in mixed si/sd) - training similar to si <1> 
.................... #define STS_OUT_OF_MEM  'm' // no more available commands (see 'group') 
.................... #define STS_ID          'x' // provide version id <1> 
.................... #define STS_PIN         'p' // return pin state <1> 
.................... #define STS_TABLE_SX    'h' // table entries count <1-2> (10-bit), table name <3-35> (counted string) 
.................... #define STS_GRAMMAR     'z' // si grammar: flags <1>, word count <2>, labels... <3-35> (n counted strings) 
.................... #define STS_TOKEN       'f' // received sonicnet token <1-2> 
.................... #define STS_MESSAGE     'g' // message status <1> (0=empty, 4/8=bits format), length <2-7> 
....................  
.................... // protocol arguments are in the range 0x40 (-1) to 0x60 (+31) inclusive 
.................... #define CR					0x0D	//a carriage return for GSM module 
.................... #define LF					0x0A	//a new line or line feed for GSM module 
.................... #define ctrlz				0x1A	//a control+Z character for GSM module 
.................... #define ARG_MIN				0x40	//argument value (-1)	// ASCII (@) 
.................... #define ARG_ZERO			0x41	//argument value (0)	// ASCII (A) 
.................... #define ARG_ONE				0x42	//argument value (1)	// ASCII (B) 
.................... #define ARG_TWO				0x43	//argument value (2)	// ASCII (C) 
.................... #define ARG_THREE			0x44	//argument value (3)	// ASCII (D) 
.................... #define ARG_FOUR			0x45	//argument value (4)	// ASCII (E) 
.................... #define ARG_FIVE			0x46	//argument value (5)	// ASCII (F) 
.................... #define ARG_SIX				0x47	//argument value (6)	// ASCII (G) 
.................... #define ARG_SEVEN			0x48	//argument value (7)	// ASCII (H) 
.................... #define ARG_EIGHT			0x49	//argument value (8)	// ASCII (I) 
.................... #define ARG_NINE			0x4A	//argument value (9)	// ASCII (J) 
.................... #define ARG_TEN				0x4B	//argument value (10)	// ASCII (K) 
.................... #define ARG_ELEVEN			0x4C	//argument value (11)	// ASCII (L) 
.................... #define ARG_TWELVE			0x4D	//argument value (12)	// ASCII (M) 
.................... #define ARG_THIRTEEN		0x4E	//argument value (13)	// ASCII (N) 
.................... #define ARG_FOURTEEN		0x4F	//argument value (14)	// ASCII (O) 
.................... #define ARG_FIFTEEN			0x50	//argument value (15)	// ASCII (P) 
.................... #define ARG_SIXTEEN			0x51	//argument value (16)	// ASCII (Q) 
.................... #define ARG_SEVENTEEN		0x52	//argument value (17)	// ASCII (R) 
.................... #define ARG_EIGHTEEN		0x53	//argument value (18)	// ASCII (S) 
.................... #define ARG_NINETEEN		0x54	//argument value (19)	// ASCII (T) 
.................... #define ARG_TWENTY			0x55	//argument value (20)	// ASCII (U) 
.................... #define ARG_TWENTYONE		0x56	//argument value (21)	// ASCII (V) 
.................... #define ARG_TWENTYTWO		0x57	//argument value (22)	// ASCII (W) 
.................... #define ARG_TWENTYTHREE		0x58	//argument value (23)	// ASCII (X) 
.................... #define ARG_TWENTYFOUR		0x59	//argument value (24)	// ASCII (Y) 
.................... #define ARG_TWENTYFIVE		0x5A	//argument value (25)	// ASCII (Z) 
.................... #define ARG_TWENTYSIX		0x5B	//argument value (26)	// ASCII (^) 
.................... #define ARG_TWENTYSEVEN		0x5C	//argument value (27)	// ASCII ([) 
.................... #define ARG_TWENTYEIGHT		0x5D	//argument value (28)	// ASCII (\) 
.................... #define ARG_TWENTYNINE		0x5E	//argument value (29)	// ASCII (]) 
.................... #define ARG_THIRTY			0x5F	//argument value (30)	// ASCII (_) 
.................... #define ARG_MAX				0x60	//argument value (31)	// ASCII (`) 
.................... #define ARG_ACK				0x20	// to read more status arguments 
....................  
.................... #endif //PROTOCOL_H 
....................  
.................... #include <groups.h> 
.................... #ifndef GROUPS_H 
.................... #define GROUPS_H 
....................  
.................... #define GROUP_1			0x42	//argument value (0)	// ASCII (A) 
.................... #define GROUP_2			0x43 
.................... #define GROUP_3			0x44 
.................... #define GROUP_4			0x45 
.................... #define GROUP_5			0x46 
.................... #define GROUP_6			0x47 
.................... #define GROUP_7			0x48 
.................... #define GROUP_8			0x49 
.................... #define GROUP_9			0x4A 
.................... #define GROUP_10		0x4B 
....................  
.................... #define TRIGGER			0x41 
.................... #define WORDSET_1		0x42 
.................... #define WORDSET_2		0x43 
.................... #define WORDSET_3		0x44 
.................... #define GRAMMAR_4		0x45 
.................... #define GRAMMAR_5		0x46 
.................... #define GRAMMAR_6		0x47 
.................... #define GRAMMAR_7		0x48 
.................... #define GRAMMAR_8		0x49 
.................... #define GRAMMAR_9		0x4A 
.................... #define GRAMMAR_10		0x4B 
....................  
.................... #endif //GROUPS_H 
....................  
.................... #fuses HS,NOLVP,NOWDT,PUT,NOPROTECT 
.................... #use delay(clock=10000000) 
*
0222:  CLRF   FEA
0224:  MOVLW  7F
0226:  MOVWF  FE9
0228:  MOVF   FEF,W
022A:  BZ    0248
022C:  MOVLW  03
022E:  MOVWF  01
0230:  CLRF   00
0232:  DECFSZ 00,F
0234:  BRA    0232
0236:  DECFSZ 01,F
0238:  BRA    0230
023A:  MOVLW  3C
023C:  MOVWF  00
023E:  DECFSZ 00,F
0240:  BRA    023E
0242:  BRA    0244
0244:  DECFSZ FEF,F
0246:  BRA    022C
0248:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=EVR,bits=8)		//HW serial pins EasyVR	||	EVR 
*
021A:  BTFSS  F9E.4
021C:  BRA    021A
021E:  MOVWF  FAD
0220:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B1,rcv=PIN_B0,stream=GSM,bits=8, SAMPLE_EARLY)		//SW serial pins Fona	||	GSM 
*
01A0:  BSF    F93.0
01A2:  BTFSC  F81.0
01A4:  BRA    01A2
01A6:  MOVLW  08
01A8:  MOVWF  00
01AA:  CLRF   x80
01AC:  BCF    00.7
01AE:  BRA    01C8
01B0:  BCF    FD8.0
01B2:  BTFSC  F81.0
01B4:  BSF    FD8.0
01B6:  RRCF   x80,F
01B8:  BSF    00.6
01BA:  BRA    01C8
01BC:  BCF    00.6
01BE:  DECFSZ 00,F
01C0:  BRA    01B0
01C2:  MOVFF  80,01
01C6:  BRA    01E0
01C8:  MOVLW  50
01CA:  BTFSC  00.7
01CC:  MOVLW  15
01CE:  MOVWF  01
01D0:  DECFSZ 01,F
01D2:  BRA    01D0
01D4:  NOP   
01D6:  BTFSC  00.7
01D8:  BRA    01AC
01DA:  BTFSC  00.6
01DC:  BRA    01BC
01DE:  BRA    01B0
01E0:  GOTO   01E6 (RETURN)
*
0A70:  BCF    F93.1
0A72:  BCF    F8A.1
0A74:  MOVLW  08
0A76:  MOVWF  01
0A78:  BRA    0A7A
0A7A:  NOP   
0A7C:  BSF    01.7
0A7E:  BRA    0A9C
0A80:  BCF    01.7
0A82:  RRCF   7F,F
0A84:  BTFSC  FD8.0
0A86:  BSF    F8A.1
0A88:  BTFSS  FD8.0
0A8A:  BCF    F8A.1
0A8C:  BSF    01.6
0A8E:  BRA    0A9C
0A90:  BCF    01.6
0A92:  DECFSZ 01,F
0A94:  BRA    0A82
0A96:  BRA    0A98
0A98:  NOP   
0A9A:  BSF    F8A.1
0A9C:  MOVLW  50
0A9E:  MOVWF  FE9
0AA0:  DECFSZ FE9,F
0AA2:  BRA    0AA0
0AA4:  BRA    0AA6
0AA6:  BTFSC  01.7
0AA8:  BRA    0A80
0AAA:  BTFSC  01.6
0AAC:  BRA    0A90
0AAE:  GOTO   0AC4 (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_A4,rcv=PIN_A3,stream=PC,bits=8)		//SW serial pins Debug	||	DB 
*
0252:  BCF    F92.4
0254:  BCF    F89.4
0256:  MOVLW  08
0258:  MOVWF  01
025A:  BRA    025C
025C:  NOP   
025E:  BSF    01.7
0260:  BRA    027E
0262:  BCF    01.7
0264:  RRCF   7F,F
0266:  BTFSC  FD8.0
0268:  BSF    F89.4
026A:  BTFSS  FD8.0
026C:  BCF    F89.4
026E:  BSF    01.6
0270:  BRA    027E
0272:  BCF    01.6
0274:  DECFSZ 01,F
0276:  BRA    0264
0278:  BRA    027A
027A:  NOP   
027C:  BSF    F89.4
027E:  MOVLW  50
0280:  MOVWF  FE9
0282:  DECFSZ FE9,F
0284:  BRA    0282
0286:  BRA    0288
0288:  BTFSC  01.7
028A:  BRA    0262
028C:  BTFSC  01.6
028E:  BRA    0272
0290:  RETURN 0
.................... #include <input.c> //this file must be ONLY included after #use rs232 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             input.c                               //// 
.................... ////                                                                   //// 
.................... //// Routines for reading user input over an RS232 stream.  User input //// 
.................... //// is in ASCII form and converted to requested binary or float       //// 
.................... //// format.                                                           //// 
.................... ////                                                                   //// 
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  //// 
.................... //// that serial stream.  If not, uses the last #use rs232().          //// 
.................... ////                                                                   //// 
.................... //// Some of these routines are not available unless you #include      //// 
.................... //// string.h and stdlib.h                                             //// 
.................... ////                                                                   //// 
.................... ////  int8 gethex() - read 2 char hex value from serial                //// 
.................... ////                                                                   //// 
.................... ////  get_string(s, max) - read max chars from serial and save to s    //// 
.................... ////                                                                   //// 
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   //// 
.................... ////     displays current string in s, allowing you to edit it.        //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8() -                                              //// 
.................... ////  int16 = get_Int16() -                                            //// 
.................... ////  int32 = get_Int32() -                                            //// 
.................... ////  float = get_float() -                                            //// 
.................... ////     Read value from serial.                                       //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8Edit(old) -                                       //// 
.................... ////  int16 = get_Int16Edit(old) -                                     //// 
.................... ////  int32 = get_Int32Edit(old) -                                     //// 
.................... ////  float = get_floatEdit(old) -                                     //// 
.................... ////     Similar to get_Int*() routines documented above, but first    //// 
.................... ////     it displays old value allowing you to edit it.                //// 
.................... ////                                                                   //// 
.................... ////  int = get_int() -                                                //// 
.................... ////  long = get_long() -                                              //// 
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   //// 
.................... ////     'long' datatypes.  The size of these datatypes depends on     //// 
.................... ////     the PIC architecture and compiler configuration.              //// 
.................... ////                                                                   //// 
.................... ////  int = get_intEdit(old) -                                         //// 
.................... ////  long = get_longEdit(old) -                                       //// 
.................... ////     Similar to get_int() and get_long() documented above,         //// 
.................... ////     but first it displays old value allowing you to edit it.      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __INPUT_C__ 
.................... #define __INPUT_C__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(STREAM_SERIAL_INPUT) 
....................    #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT) 
....................    #define InputPutc(c)    fputc(c, STREAM_SERIAL_INPUT) 
....................    #define InputGetc()     fgetc(STREAM_SERIAL_INPUT) 
.................... #else 
....................    #define InputKbhit()    kbhit() 
....................    #define InputPutc(c)    putc(c) 
....................    #define InputGetc()     getc() 
.................... #endif 
....................  
.................... unsigned int8 gethex1() { 
....................    char digit; 
....................  
....................    digit = InputGetc(); 
....................  
....................    InputPutc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... unsigned int8 gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    max-=2; 
....................    len=0; 
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... #ifdef _STRING 
.................... void get_stringEdit(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    len = strlen(s); 
....................  
....................    if (len) 
....................    { 
....................      #if defined(STREAM_SERIAL_INPUT) 
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s); 
....................      #else 
....................       printf("%s", s); 
....................      #endif 
....................    } 
....................  
....................    max-=2; 
....................  
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
.................... #endif 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... signed int8 get_Int8(void) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int8 get_Int8Edit(signed int8 old) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   sprintf(s, "%d", old); 
....................   get_stringEdit(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... signed int16 get_Int16(void) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int16 get_Int16Edit(signed int16 old) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... signed int32 get_Int32(void) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int32 get_Int32Edit(signed int32 old) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... float get_floatEdit(float old) { 
....................   char s[20]; 
....................   float f; 
....................  
....................   sprintf(s, "%f", old); 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #define get_int()       get_Int16() 
....................    #define get_intEdit()   get_Int16Edit() 
....................    #define get_long()      get_Int32() 
....................    #define get_longEdit()  get_Int32Edit() 
.................... #else 
....................    #define get_int()       get_Int8() 
....................    #define get_intEdit()   get_Int8Edit() 
....................    #define get_long()      get_Int16() 
....................    #define get_longEdit()  get_Int16Edit() 
.................... #endif 
....................  
.................... #endif   //_STDLIB 
....................  
.................... #endif   //__INPUT_C__ 
....................  
....................  
....................  
....................  
.................... //                    =======================                    // 
.................... //====================E N U M E R A T I O N S====================// 
.................... //                    =======================                    // 
.................... //********Variable Def**********// 
.................... 	volatile int reset = FALSE; 
.................... 	/////////////////// 
.................... 	//these are automatically stored in RAM 
....................  	char AT[] = "AT\r\n";// To initialize mode 
.................... 	// char OK[] = "OK"; 
.................... 	char save[] = "AT&W\r\n"; 
.................... 	char noecho[] = "ATE0\r\n"; 
.................... 	char mode_text[] = "AT+CMGF=1\r\n";   // to set text mode 
.................... 	char endCall[] = "ATH\r\n"; 
.................... 	char ansCall[] = "ATA\r\n"; 
.................... 	//char ring[] = "\r\nRing\r\n"; 
.................... 	//char mode_text[] = "AT+CMGF=1";   // to set text mode 
.................... 	//char char_mode[] = "AT+CSCS=\"GSM\"";   // to set character mode 
.................... 	//char param[] = "AT+CSMP=17,167,0,0";   // set the parameter of character 
.................... 	//char mobile_no[] = "AT+CMGS=\"+92090078601\"";   //use to set recepient number and mesg 
.................... 	 
.................... //******Custom Sound Table******// 
.................... enum soundtable{				//constants for playback 
.................... 	BEEP, 
.................... 	SND_zero, SND_one, SND_two, SND_three, SND_four, SND_five, SND_six, SND_seven, SND_eight, SND_nine,  
.................... 	SND_please_say_a_command, 
.................... 	SND_hello_please_say_a_command, 
.................... 	SND_who_would_you_like_to_call, 
.................... 	SND_calling, 
.................... 	SND_doctor, 
.................... 	SND_say_send_to_place_the_call, 
.................... 	SND_say_reject_to_reject_the_call, 
.................... 	SND_say_answer_to_answer_the_call, 
.................... 	SND_say_end_to_cancel, 
.................... 	SND_turning_on_LED, 
.................... 	SND_turning_on_light_bulb, 
.................... 	SND_turning_off_led, 
.................... 	SND_turning_off_light_bulb, 
.................... 	SND_you_have_an_incoming_call, 
.................... 	SND_command_accepted, 
.................... 	 
.................... }; 
.................... enum trigger0{					//constants for trigger 
.................... 	Robot, 
.................... }; 
.................... enum wordSet1{					//constants for wordset1 
.................... 	WS1_ACTION, WS1_MOVE, WS1_TURN, WS1_RUN, WS1_LOOK, WS1_ATTACK, WS1_STOP, WS1_HELLO, 
.................... }; 
.................... enum wordset2{					//constants for wordset2 
.................... 	WS2_LEFT, WS2_RIGHT, WS2_UP, WS2_DOWN, WS2_FORWARD, WS2_BACKWARD, 
.................... }; 
.................... enum wordset3{					//constants for wordset3 
.................... 	WS3_ZERO, WS3_ONE, WS3_TWO, WS3_THREE, WS3_FOUR, WS3_FIVE, WS3_SIX, WS3_SEVEN, WS3_EIGHT, WS3_NINE, WS3_TEN, 
.................... }; 
.................... enum grammar4{					//constants for grammar4 
.................... 	GR4_OK_EASYVEEAR 
.................... }; 
.................... enum grammar5{					//constants for grammar5 
.................... 	GR5_NEXT, GR5_PREVIOUS, GR5_STOP, GR5_PLAY, GR5_PAUSE, GR5_RECORD, 
.................... }; 
.................... enum grammar6{					//constants for grammar6 
.................... 	GR6_TURN_ON, GR6_SWITCH_OFF, GR6_INCREASE, GR6_DECREASE, GR6_OPEN, GR6_CLOSE, GR6_START, GR6_STOP, 
.................... }; 
.................... enum grammar7{					//constants for grammar7 
.................... 	GR7_DOOR, GR7_T_V, GR7_TEMPERATURE, GR7_WINDOW, GR7_MUSIC, GR7_LIGHT, GR7_TIMER, GR7_OVEN, GR7_WASHING_MACHINE, GR7_DISH_WASHER, 
.................... }; 
.................... enum grammar8{					//constants for grammar8 
.................... 	GR8_YES, GR8_NO, 
.................... }; 
.................... enum grammar9{					//constants for grammar9 
.................... 	GR9_HELLO_DEVICE, 
.................... }; 
.................... enum grammar10{					//constants for grammar10 
.................... 	GR10_PASSWORD_SETUP, GR10_PASSWORD_ACTIVATED, GR10_CURTAIN_UP, GR10_CURTAIN_DOWN, GR10_LIGHTS_ON, GR10_LIGHTS_OFF, 
.................... }; 
....................  
.................... enum group1{					//constants for action words 
.................... 	G1_CALL, G1_ANSWER, G1_LIGHTS, G1_LED, G1_OTHER, G1_END 
.................... }; 
.................... enum group2{					//constants for target of action words 
.................... 	G2_DOCTOR, G2_PARENT, G2_MOM, G2_DAD, G2_SON, G2_DAUGHTER, G2_ON, G2_OFF, G2_OTHER, 
.................... }; 
.................... enum group3{ 
.................... 	G3_ZERO, G3_ONE, G3_TWO, G3_THREE, G3_FOUR, G3_FIVE, G3_SIX, G3_SEVEN, G3_EIGHT, G3_NINE, G3_TEN 
.................... }; 
....................  
.................... //State definitions, states are the routine the program jumps to 
.................... enum states { 
.................... 	S_RESET, S_WS1, S_WS2, S_WS3, S_GP1, S_GP2, S_GP3, S_RECEIVE_CALL, 
.................... }; 
.................... volatile int current_state = S_RESET; 
....................  
....................  
....................  
.................... //                   ========================                    // 
.................... //===================F U N C T I O N  D E F N====================// 
.................... //                   ========================                    // 
.................... //**********System Fns**********// 
.................... void blinkA0(int _a){			//LED indicator 
*
092E:  CLRF   7E
.................... 	int _i = 0; 
.................... 	for (_i; _i < _a; _i++ ){ 
0930:  MOVF   7D,W
0932:  SUBWF  7E,W
0934:  BC    094E
.................... 		output_high(PIN_A0); 
0936:  BCF    F92.0
0938:  BSF    F89.0
.................... 		delay_ms(50); 
093A:  MOVLW  32
093C:  MOVWF  7F
093E:  RCALL  0222
.................... 		output_low(PIN_A0); 
0940:  BCF    F92.0
0942:  BCF    F89.0
.................... 		delay_ms(100); 
0944:  MOVLW  64
0946:  MOVWF  7F
0948:  RCALL  0222
094A:  INCF   7E,F
094C:  BRA    0930
.................... 	} 
094E:  RETURN 0
.................... } 
.................... void blinkA1(int _a){			//LED indicator 
.................... 	int _i = 0;	 
.................... 	for (_i; _i < _a; _i++ ){ 
.................... 		output_high(PIN_A1); 
.................... 		delay_ms(50); 
.................... 		output_low(PIN_A1); 
.................... 		delay_ms(100); 
.................... 	} 
.................... } 
.................... void blinkD2(int _a){			//bulb indicator 
.................... 	int _i = 0;	 
.................... 	for (_i; _i < _a; _i++ ){ 
.................... 		output_high(PIN_D2); 
.................... 		delay_ms(50); 
.................... 		output_low(PIN_D2); 
.................... 		delay_ms(100); 
.................... 	} 
.................... } 
.................... void ms25(){ 
.................... 	delay_ms(30);}		//easy way to call ms25(25) 
*
024A:  MOVLW  1E
024C:  MOVWF  7F
024E:  RCALL  0222
0250:  RETURN 0
.................... void print_debug(char dbg){ 
.................... 	fputc(dbg,PC); 
*
0292:  MOVFF  7D,7F
0296:  RCALL  0252
0298:  RETURN 0
.................... } 
.................... 	 
.................... //***********Fona Fns***********// 
.................... void useGSM(){fputc(NUL,GSM);}			//ensures get_string()[from input.c] uses GSM RS232 stream 
.................... void usePC(){fputc(NUL,PC);}			//ensures get_string()[from input.c] uses GSM RS232 stream 
.................... void reset_gsm(){ 
.................... 	output_low(PIN_C5); 
.................... 	delay_ms(100); 
.................... 	output_high(PIN_C5); 
.................... 	delay_ms(10000);	//delays the code so that the GSM module would be able to reconnect to the network 
.................... } 
.................... /* boolean gsmReplyOK(char _reply_gsm[]){	//checks to see if the reply is ring...might not actually be needed 
.................... 	if(strncmp(_reply_gsm,OK,strlen(OK))==0){ 
.................... 		return true; 
.................... 	}else{ 
.................... 		return false; 
.................... 	} 
.................... } */ 
.................... void gsmSetup(){ 
.................... //NOTE: we do not necessarily need to check to see if the data received is "OK". we can assume that it will happen 
.................... 	fprintf(GSM,AT); 
.................... 	delay_us(50); 
.................... 	fprintf(GSM,noecho); 
.................... 	delay_us(50); 
.................... 	fprintf(GSM,mode_text); 
.................... 	delay_us(50); 
.................... 	fprintf(GSM,save); 
.................... 	delay_us(50); 
.................... 	 
.................... } 
.................... void gsmAction(char _a){ 
.................... 	switch (_a){ 
.................... 		case 'a': 
.................... 			fprintf(GSM,ansCall); 
.................... 			fprintf(PC,"Answering..."); 
.................... 			break; 
.................... 		case 'c': 
.................... 			fprintf(GSM,"ATD+18686822015;\r\n"); 
.................... 			fprintf(PC,"Calling..."); 
.................... 			break; 
.................... 		case 'e': 
.................... 			fprintf(GSM,endCall); 
.................... 			fprintf(PC,"Ending..."); 
.................... 			break; 
.................... 		default: _a = NUL; 
.................... 		break; 
.................... 	} 
.................... } 
....................  
.................... void halt(){						//stop current action 
029A:  CLRF   7B
.................... 	char _rec_halt = NUL; 
.................... 	while (_rec_halt != STS_SUCCESS){ 
029C:  MOVF   7B,W
029E:  SUBLW  6F
02A0:  BZ    02BC
.................... 		fputc(CMD_BREAK,EVR); 
02A2:  MOVLW  62
02A4:  RCALL  021A
.................... 		ms25(); 
02A6:  RCALL  024A
.................... 		if (kbhit(EVR)) _rec_halt = fgetc(EVR); 
02A8:  BTFSS  F9E.5
02AA:  BRA    02B4
02AC:  BTFSS  F9E.5
02AE:  BRA    02AC
02B0:  MOVFF  FAE,7B
.................... 		print_debug(_rec_halt); 
02B4:  MOVFF  7B,7D
02B8:  RCALL  0292
02BA:  BRA    029C
.................... 	} 
.................... 	_rec_halt = NUL; 
02BC:  CLRF   7B
02BE:  GOTO   0E00 (RETURN)
.................... } 
.................... void wake_EVR(){				//put device to sleep and wake on double clap or received a character 
*
031A:  CLRF   7B
031C:  CLRF   7C
.................... 	char _rec_sleep = NUL; 
.................... 	char back_from_power_down = NUL; 
.................... 	while (_rec_sleep != STS_SUCCESS){ 
031E:  MOVF   7B,W
0320:  SUBLW  6F
0322:  BZ    0344
.................... 		fputc(CMD_SLEEP,EVR); 
0324:  MOVLW  73
0326:  RCALL  021A
.................... 		ms25(); 
0328:  RCALL  024A
.................... 		fputc(ARG_THREE,EVR); 
032A:  MOVLW  44
032C:  RCALL  021A
.................... 		ms25(); 
032E:  RCALL  024A
.................... 		if (kbhit(EVR)) _rec_sleep = fgetc(EVR); 
0330:  BTFSS  F9E.5
0332:  BRA    033C
0334:  BTFSS  F9E.5
0336:  BRA    0334
0338:  MOVFF  FAE,7B
.................... 		print_debug(_rec_sleep); 
033C:  MOVFF  7B,7D
0340:  RCALL  0292
0342:  BRA    031E
.................... 	} 
.................... 	while (back_from_power_down != STS_AWAKEN){ 
0344:  MOVF   7C,W
0346:  SUBLW  77
0348:  BZ    035E
.................... 		if (kbhit(EVR))	back_from_power_down = fgetc(EVR); 
034A:  BTFSS  F9E.5
034C:  BRA    0356
034E:  BTFSS  F9E.5
0350:  BRA    034E
0352:  MOVFF  FAE,7C
.................... 		print_debug(back_from_power_down); 
0356:  MOVFF  7C,7D
035A:  RCALL  0292
035C:  BRA    0344
.................... 	} 
.................... 	back_from_power_down = NUL; 
035E:  CLRF   7C
.................... 	_rec_sleep = NUL; 
0360:  CLRF   7B
0362:  GOTO   0D00 (RETURN)
.................... } 
.................... void setLang(char _whatLang){		//set the language based on the argument passed 
*
02C2:  CLRF   7C
.................... 	char _rec_setlang = NUL; 
.................... 	while (_rec_setlang != STS_SUCCESS){ 
02C4:  MOVF   7C,W
02C6:  SUBLW  6F
02C8:  BZ    02EA
.................... 		fputc(CMD_LANGUAGE,EVR); 
02CA:  MOVLW  6C
02CC:  RCALL  021A
.................... 		ms25(); 
02CE:  RCALL  024A
.................... 		fputc(_whatLang,EVR); 
02D0:  MOVF   7B,W
02D2:  RCALL  021A
.................... 		ms25(); 
02D4:  RCALL  024A
.................... 		if (kbhit(EVR)) _rec_setlang = fgetc(EVR); 
02D6:  BTFSS  F9E.5
02D8:  BRA    02E2
02DA:  BTFSS  F9E.5
02DC:  BRA    02DA
02DE:  MOVFF  FAE,7C
.................... 		print_debug(_rec_setlang); 
02E2:  MOVFF  7C,7D
02E6:  RCALL  0292
02E8:  BRA    02C4
.................... 	} 
02EA:  GOTO   0E08 (RETURN)
.................... } 
.................... void setTimeout(char _period){		//set a period of the timeout based on the argument passed 
02EE:  CLRF   7C
.................... 	char _rec_time = NUL; 
.................... 	while (_rec_time != STS_SUCCESS){ 
02F0:  MOVF   7C,W
02F2:  SUBLW  6F
02F4:  BZ    0316
.................... 		fputc(CMD_TIMEOUT,EVR); 
02F6:  MOVLW  6F
02F8:  RCALL  021A
.................... 		ms25(); 
02FA:  RCALL  024A
.................... 		fputc(_period,EVR); 
02FC:  MOVF   7B,W
02FE:  RCALL  021A
.................... 		ms25(); 
0300:  RCALL  024A
.................... 		if (kbhit(EVR)) _rec_time = fgetc(EVR); 
0302:  BTFSS  F9E.5
0304:  BRA    030E
0306:  BTFSS  F9E.5
0308:  BRA    0306
030A:  MOVFF  FAE,7C
.................... 		print_debug(_rec_time); 
030E:  MOVFF  7C,7D
0312:  RCALL  0292
0314:  BRA    02F0
.................... 	} 
0316:  GOTO   0E10 (RETURN)
.................... } 
....................  
.................... void listenWS1(){//listens to wordset1 and determines which word was spoken 
*
0894:  CLRF   7B
0896:  CLRF   7C
.................... 	char rec_WS1 = NUL; 
.................... 	char cmd_WS1 = NUL; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
0898:  MOVLW  69
089A:  RCALL  021A
.................... 	ms25(); 
089C:  RCALL  024A
.................... 	fputc(ARG_ONE,EVR); 
089E:  MOVLW  42
08A0:  RCALL  021A
.................... 	ms25(); 
08A2:  RCALL  024A
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
08A4:  BCF    F92.0
08A6:  BSF    F89.0
.................... 	if (kbhit()) rec_WS1 = fgetc(EVR); 
08A8:  BTFSS  F9E.5
08AA:  BRA    08B4
08AC:  BTFSS  F9E.5
08AE:  BRA    08AC
08B0:  MOVFF  FAE,7B
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
08B4:  BCF    F92.0
08B6:  BCF    F89.0
.................... 	if (rec_WS1 == STS_SIMILAR){ 
08B8:  MOVF   7B,W
08BA:  SUBLW  73
08BC:  BNZ   091C
.................... 		fputc(ARG_ACK,EVR); 
08BE:  MOVLW  20
08C0:  RCALL  021A
.................... 		ms25(); 
08C2:  RCALL  024A
.................... 		rec_WS1 = NUL; 
08C4:  CLRF   7B
.................... 		rec_WS1 = fgetc(EVR); 
08C6:  BTFSS  F9E.5
08C8:  BRA    08C6
08CA:  MOVFF  FAE,7B
.................... 		cmd_WS1 = rec_WS1 - ARG_ZERO; 
08CE:  MOVLW  41
08D0:  SUBWF  7B,W
08D2:  MOVWF  7C
.................... 		print_debug(cmd_WS1); 
08D4:  MOVFF  7C,7D
08D8:  RCALL  0292
.................... 		switch (cmd_WS1){ 
08DA:  MOVF   7C,W
08DC:  BZ    08FC
08DE:  XORLW  01
08E0:  BZ    08FE
08E2:  XORLW  03
08E4:  BZ    0900
08E6:  XORLW  01
08E8:  BZ    0902
08EA:  XORLW  07
08EC:  BZ    0904
08EE:  XORLW  01
08F0:  BZ    0906
08F2:  XORLW  03
08F4:  BZ    0908
08F6:  XORLW  01
08F8:  BZ    090A
08FA:  BRA    0916
.................... 			case WS1_ACTION: 
.................... 				break; 
08FC:  BRA    091A
.................... 			case WS1_MOVE: 
.................... 				break; 
08FE:  BRA    091A
.................... 			case WS1_TURN: 
.................... 				break; 
0900:  BRA    091A
.................... 			case WS1_RUN: 
.................... 				break; 
0902:  BRA    091A
.................... 			case WS1_LOOK: 
.................... 				break; 
0904:  BRA    091A
.................... 			case WS1_ATTACK: 
.................... 				break; 
0906:  BRA    091A
.................... 			case WS1_STOP: 
.................... 				break; 
0908:  BRA    091A
.................... 			case WS1_HELLO: 
.................... 				fprintf(PC,"you said hello"); 
090A:  MOVLW  90
090C:  MOVWF  FF6
090E:  MOVLW  01
0910:  MOVWF  FF7
0912:  BRA    0872
.................... 				break; 
0914:  BRA    091A
.................... 			default:	rec_WS1 = STS_SIMILAR; 
0916:  MOVLW  73
0918:  MOVWF  7B
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
091A:  BRA    092A
.................... 	if (rec_WS1 == STS_TIMEOUT){ 
091C:  MOVF   7B,W
091E:  SUBLW  74
0920:  BNZ   0924
....................  
.................... 		break; 
.................... 	}else 
0922:  BRA    092A
.................... 	if (rec_WS1 == STS_ERROR){ 
0924:  MOVF   7B,W
0926:  SUBLW  65
0928:  BNZ   092A
....................  
.................... 		break; 
.................... 	} 
092A:  GOTO   0D10 (RETURN)
.................... } 
.................... void listenWS2(){//listens to wordset2 and determines which word was spoken 
*
0950:  CLRF   7B
0952:  CLRF   7C
.................... 	char rec_WS2 = NUL; 
.................... 	char cmd_WS2 = NUL; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
0954:  MOVLW  69
0956:  RCALL  021A
.................... 	ms25(); 
0958:  RCALL  024A
.................... 	fputc(ARG_TWO,EVR); 
095A:  MOVLW  43
095C:  RCALL  021A
.................... 	ms25(); 
095E:  RCALL  024A
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
0960:  BCF    F92.0
0962:  BSF    F89.0
.................... 	if (kbhit()) rec_WS2 = fgetc(EVR); 
0964:  BTFSS  F9E.5
0966:  BRA    0970
0968:  BTFSS  F9E.5
096A:  BRA    0968
096C:  MOVFF  FAE,7B
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
0970:  BCF    F92.0
0972:  BCF    F89.0
.................... 	if (rec_WS2 == STS_SIMILAR){ 
0974:  MOVF   7B,W
0976:  SUBLW  73
0978:  BNZ   09BC
.................... 		fputc(ARG_ACK,EVR); 
097A:  MOVLW  20
097C:  RCALL  021A
.................... 		ms25(); 
097E:  RCALL  024A
.................... 		rec_WS2 = NUL; 
0980:  CLRF   7B
.................... 		rec_WS2 = fgetc(EVR); 
0982:  BTFSS  F9E.5
0984:  BRA    0982
0986:  MOVFF  FAE,7B
.................... 		cmd_WS2 = rec_WS2 - ARG_ZERO; 
098A:  MOVLW  41
098C:  SUBWF  7B,W
098E:  MOVWF  7C
.................... 		switch (cmd_WS2){ 
0990:  MOVF   7C,W
0992:  BZ    09AA
0994:  XORLW  01
0996:  BZ    09AC
0998:  XORLW  03
099A:  BZ    09AE
099C:  XORLW  01
099E:  BZ    09B0
09A0:  XORLW  07
09A2:  BZ    09B2
09A4:  XORLW  01
09A6:  BZ    09B4
09A8:  BRA    09B6
.................... 			case WS2_LEFT: 
.................... 				break; 
09AA:  BRA    09BA
.................... 			case WS2_RIGHT: 
.................... 				break; 
09AC:  BRA    09BA
.................... 			case WS2_UP: 
.................... 				break;	 
09AE:  BRA    09BA
.................... 			case WS2_DOWN: 
.................... 				break; 
09B0:  BRA    09BA
.................... 			case WS2_FORWARD: 
.................... 				break; 
09B2:  BRA    09BA
.................... 			case WS2_BACKWARD: 
.................... 				break; 
09B4:  BRA    09BA
.................... 			default:	rec_WS2 = STS_SIMILAR; 
09B6:  MOVLW  73
09B8:  MOVWF  7B
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
09BA:  BRA    09CA
.................... 	if (rec_WS2 == STS_TIMEOUT){ 
09BC:  MOVF   7B,W
09BE:  SUBLW  74
09C0:  BNZ   09C4
.................... 		break; 
.................... 	}else 
09C2:  BRA    09CA
.................... 	if (rec_WS2 == STS_ERROR){ 
09C4:  MOVF   7B,W
09C6:  SUBLW  65
09C8:  BNZ   09CA
.................... 		break; 
.................... 	} 
09CA:  GOTO   0D1A (RETURN)
.................... } 
.................... void listenWS3(){//listens to wordset3 and determines which word was spoken 
09CE:  CLRF   7B
09D0:  CLRF   7C
.................... 	char rec_WS3 = NUL; 
.................... 	char cmd_WS3 = NUL; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
09D2:  MOVLW  69
09D4:  RCALL  021A
.................... 	ms25(); 
09D6:  RCALL  024A
.................... 	fputc(ARG_THREE,EVR); 
09D8:  MOVLW  44
09DA:  RCALL  021A
.................... 	ms25(); 
09DC:  RCALL  024A
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
09DE:  BCF    F92.0
09E0:  BSF    F89.0
.................... 	if (kbhit()) rec_WS3 = fgetc(EVR); 
09E2:  BTFSS  F9E.5
09E4:  BRA    09EE
09E6:  BTFSS  F9E.5
09E8:  BRA    09E6
09EA:  MOVFF  FAE,7B
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
09EE:  BCF    F92.0
09F0:  BCF    F89.0
.................... 	if (rec_WS3 == STS_SIMILAR){ 
09F2:  MOVF   7B,W
09F4:  SUBLW  73
09F6:  BNZ   0A5E
.................... 		fputc(ARG_ACK,EVR); 
09F8:  MOVLW  20
09FA:  RCALL  021A
.................... 		ms25(); 
09FC:  RCALL  024A
.................... 		rec_WS3 = NUL; 
09FE:  CLRF   7B
.................... 		rec_WS3 = fgetc(EVR); 
0A00:  BTFSS  F9E.5
0A02:  BRA    0A00
0A04:  MOVFF  FAE,7B
.................... 		cmd_WS3 = rec_WS3 - ARG_ZERO; 
0A08:  MOVLW  41
0A0A:  SUBWF  7B,W
0A0C:  MOVWF  7C
.................... 		switch (cmd_WS3){ 
0A0E:  MOVF   7C,W
0A10:  BZ    0A3C
0A12:  XORLW  01
0A14:  BZ    0A3E
0A16:  XORLW  03
0A18:  BZ    0A46
0A1A:  XORLW  01
0A1C:  BZ    0A48
0A1E:  XORLW  07
0A20:  BZ    0A4A
0A22:  XORLW  01
0A24:  BZ    0A4C
0A26:  XORLW  03
0A28:  BZ    0A4E
0A2A:  XORLW  01
0A2C:  BZ    0A50
0A2E:  XORLW  0F
0A30:  BZ    0A52
0A32:  XORLW  01
0A34:  BZ    0A54
0A36:  XORLW  03
0A38:  BZ    0A56
0A3A:  BRA    0A58
.................... 			case WS3_ZERO: 
.................... 				break; 
0A3C:  BRA    0A5C
.................... 			case WS3_ONE: 
.................... 				blinkA0(1); 
0A3E:  MOVLW  01
0A40:  MOVWF  7D
0A42:  RCALL  092E
.................... 				break; 
0A44:  BRA    0A5C
.................... 			case WS3_TWO: 
.................... 				break; 
0A46:  BRA    0A5C
.................... 			case WS3_THREE: 
.................... 				break; 
0A48:  BRA    0A5C
.................... 			case WS3_FOUR: 
.................... 				break; 
0A4A:  BRA    0A5C
.................... 			case WS3_FIVE: 
.................... 				break; 
0A4C:  BRA    0A5C
.................... 			case WS3_SIX: 
.................... 				break; 
0A4E:  BRA    0A5C
.................... 			case WS3_SEVEN: 
.................... 				break; 
0A50:  BRA    0A5C
.................... 			case WS3_EIGHT: 
.................... 				break; 
0A52:  BRA    0A5C
.................... 			case WS3_NINE: 
.................... 				break; 
0A54:  BRA    0A5C
.................... 			case WS3_TEN: 
.................... 				break; 
0A56:  BRA    0A5C
.................... 			default:		rec_WS3 = STS_SIMILAR; 
0A58:  MOVLW  73
0A5A:  MOVWF  7B
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
0A5C:  BRA    0A6C
.................... 	if (rec_WS3 == STS_TIMEOUT){ 
0A5E:  MOVF   7B,W
0A60:  SUBLW  74
0A62:  BNZ   0A66
.................... 		break; 
.................... 	}else 
0A64:  BRA    0A6C
.................... 	if (rec_WS3 == STS_ERROR){ 
0A66:  MOVF   7B,W
0A68:  SUBLW  65
0A6A:  BNZ   0A6C
.................... 		break; 
.................... 	} 
0A6C:  GOTO   0D24 (RETURN)
.................... } 
.................... void listenGP1(){//listens to group1 and determines which word was spoken 
*
0AD6:  CLRF   7B
0AD8:  CLRF   7C
.................... 	char rec_GP1 = NUL; 
.................... 	char cmd_GP1 = NUL; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
0ADA:  MOVLW  64
0ADC:  CALL   021A
.................... 	ms25(); 
0AE0:  CALL   024A
.................... 	fputc(ARG_ONE,EVR); 
0AE4:  MOVLW  42
0AE6:  CALL   021A
.................... 	ms25(); 
0AEA:  CALL   024A
.................... 	output_high(PIN_A0);//indicate that the device is listening 
0AEE:  BCF    F92.0
0AF0:  BSF    F89.0
.................... 	if (kbhit()) rec_GP1 = fgetc(EVR); 
0AF2:  BTFSS  F9E.5
0AF4:  BRA    0AFE
0AF6:  BTFSS  F9E.5
0AF8:  BRA    0AF6
0AFA:  MOVFF  FAE,7B
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
0AFE:  BCF    F92.0
0B00:  BCF    F89.0
.................... 	if (rec_GP1 == STS_SIMILAR){ 
0B02:  MOVF   7B,W
0B04:  SUBLW  73
0B06:  BNZ   0B74
.................... 		fputc(ARG_ACK,EVR); 
0B08:  MOVLW  20
0B0A:  CALL   021A
.................... 		ms25(); 
0B0E:  CALL   024A
.................... 		rec_GP1 = NUL; 
0B12:  CLRF   7B
.................... 		rec_GP1 = fgetc(EVR); 
0B14:  BTFSS  F9E.5
0B16:  BRA    0B14
0B18:  MOVFF  FAE,7B
.................... 		cmd_GP1 = rec_GP1 - ARG_ZERO; 
0B1C:  MOVLW  41
0B1E:  SUBWF  7B,W
0B20:  MOVWF  7C
.................... 		switch (cmd_GP1){ 
0B22:  MOVF   7C,W
0B24:  BZ    0B3C
0B26:  XORLW  01
0B28:  BZ    0B42
0B2A:  XORLW  03
0B2C:  BZ    0B52
0B2E:  XORLW  01
0B30:  BZ    0B58
0B32:  XORLW  07
0B34:  BZ    0B5E
0B36:  XORLW  01
0B38:  BZ    0B64
0B3A:  BRA    0B6E
.................... 			case G1_CALL: 
.................... 					current_state = S_GP2; 
0B3C:  MOVLW  05
0B3E:  MOVWF  62
.................... 				break; 
0B40:  BRA    0B72
.................... 			case G1_ANSWER: 
.................... 					fprintf(GSM,ansCall); //send a command to the GSM module to answer the call 
0B42:  CLRF   FEA
0B44:  MOVLW  5C
0B46:  MOVWF  FE9
0B48:  RCALL  0AB2
.................... 					blinkA0(1); 
0B4A:  MOVLW  01
0B4C:  MOVWF  7D
0B4E:  RCALL  092E
.................... 				break; 
0B50:  BRA    0B72
.................... 			case G1_LIGHTS: 
.................... 					current_state = S_GP2;//proceed to group 2 
0B52:  MOVLW  05
0B54:  MOVWF  62
.................... 				break; 
0B56:  BRA    0B72
.................... 			case G1_LED: 
.................... 					current_state = S_GP2;//proceed to group 2 
0B58:  MOVLW  05
0B5A:  MOVWF  62
.................... 				break; 
0B5C:  BRA    0B72
.................... 			case G1_OTHER: 
.................... 					current_state = S_GP3;//proceed to group 3 
0B5E:  MOVLW  06
0B60:  MOVWF  62
.................... 				break; 
0B62:  BRA    0B72
.................... 			case G1_END: 
.................... 				fprintf(GSM,endCall); //send a command to the GSM module to end the call 
0B64:  CLRF   FEA
0B66:  MOVLW  56
0B68:  MOVWF  FE9
0B6A:  RCALL  0AB2
.................... 				break; 
0B6C:  BRA    0B72
.................... 			default:		rec_GP1 = STS_SIMILAR; 
0B6E:  MOVLW  73
0B70:  MOVWF  7B
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
0B72:  BRA    0B8A
.................... 	if (rec_GP1 == STS_TIMEOUT){ 
0B74:  MOVF   7B,W
0B76:  SUBLW  74
0B78:  BNZ   0B80
.................... 		current_state = S_GP1; //this would restart the listening process for the group 
0B7A:  MOVLW  04
0B7C:  MOVWF  62
.................... 		break; 
.................... 	}else 
0B7E:  BRA    0B8A
.................... 	if (rec_GP1 == STS_ERROR){ 
0B80:  MOVF   7B,W
0B82:  SUBLW  65
0B84:  BNZ   0B8A
.................... 		current_state = S_GP1; //this would restart the listening process for the group 
0B86:  MOVLW  04
0B88:  MOVWF  62
.................... 		break; 
.................... 	} 
0B8A:  GOTO   0D2E (RETURN)
....................  
.................... } 
.................... void listenGP2(){//listens to group2 and determines which word was spoken 
0B8E:  CLRF   7B
0B90:  CLRF   7C
.................... 	char rec_GP2 = NUL; 
.................... 	char cmd_GP2 = NUL; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
0B92:  MOVLW  64
0B94:  CALL   021A
.................... 	ms25(); 
0B98:  CALL   024A
.................... 	fputc(ARG_TWO,EVR); 
0B9C:  MOVLW  43
0B9E:  CALL   021A
.................... 	ms25(); 
0BA2:  CALL   024A
.................... 	output_high(PIN_A0);//indicate that the device is listening 
0BA6:  BCF    F92.0
0BA8:  BSF    F89.0
.................... 	if (kbhit()) rec_GP2 = fgetc(EVR); 
0BAA:  BTFSS  F9E.5
0BAC:  BRA    0BB6
0BAE:  BTFSS  F9E.5
0BB0:  BRA    0BAE
0BB2:  MOVFF  FAE,7B
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
0BB6:  BCF    F92.0
0BB8:  BCF    F89.0
.................... 	if (rec_GP2 == STS_SIMILAR){ 
0BBA:  MOVF   7B,W
0BBC:  SUBLW  73
0BBE:  BNZ   0C18
.................... 		fputc(ARG_ACK,EVR); 
0BC0:  MOVLW  20
0BC2:  CALL   021A
.................... 		ms25(); 
0BC6:  CALL   024A
.................... 		rec_GP2 = NUL; 
0BCA:  CLRF   7B
.................... 		rec_GP2 = fgetc(EVR); 
0BCC:  BTFSS  F9E.5
0BCE:  BRA    0BCC
0BD0:  MOVFF  FAE,7B
.................... 		cmd_GP2 = rec_GP2 - ARG_ZERO; 
0BD4:  MOVLW  41
0BD6:  SUBWF  7B,W
0BD8:  MOVWF  7C
.................... 		switch (cmd_GP2){ 
0BDA:  MOVF   7C,W
0BDC:  BZ    0BFC
0BDE:  XORLW  01
0BE0:  BZ    0BFE
0BE2:  XORLW  03
0BE4:  BZ    0C06
0BE6:  XORLW  01
0BE8:  BZ    0C08
0BEA:  XORLW  07
0BEC:  BZ    0C0A
0BEE:  XORLW  01
0BF0:  BZ    0C0C
0BF2:  XORLW  03
0BF4:  BZ    0C0E
0BF6:  XORLW  01
0BF8:  BZ    0C10
0BFA:  BRA    0C12
.................... 			case G2_DOCTOR: 
.................... 				break; 
0BFC:  BRA    0C16
.................... 			case G2_PARENT: 
.................... 				blinkA0(1); 
0BFE:  MOVLW  01
0C00:  MOVWF  7D
0C02:  RCALL  092E
.................... 				break; 
0C04:  BRA    0C16
.................... 			case G2_MOM: 
.................... 				break; 
0C06:  BRA    0C16
.................... 			case G2_DAD: 
.................... 				break; 
0C08:  BRA    0C16
.................... 			case G2_SON: 
.................... 				break; 
0C0A:  BRA    0C16
.................... 			case G2_DAUGHTER: 
.................... 				break; 
0C0C:  BRA    0C16
.................... 			case G2_ON: 
.................... 				break; 
0C0E:  BRA    0C16
.................... 			case G2_OFF: 
.................... 				break; 
0C10:  BRA    0C16
.................... 			default:		rec_GP2 = STS_SIMILAR; 
0C12:  MOVLW  73
0C14:  MOVWF  7B
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
0C16:  BRA    0C26
.................... 	if (rec_GP2 == STS_TIMEOUT){ 
0C18:  MOVF   7B,W
0C1A:  SUBLW  74
0C1C:  BNZ   0C20
....................  
.................... 		break; 
.................... 	}else 
0C1E:  BRA    0C26
.................... 	if (rec_GP2 == STS_ERROR){ 
0C20:  MOVF   7B,W
0C22:  SUBLW  65
0C24:  BNZ   0C26
.................... 		break; 
.................... 	} 
0C26:  GOTO   0D38 (RETURN)
.................... } 
.................... void listenGP3(){//listens to group3 and determines which word was spoken 
0C2A:  CLRF   7B
0C2C:  CLRF   7C
.................... 	char rec_GP3 = NUL; 
.................... 	char cmd_GP3 = NUL; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
0C2E:  MOVLW  64
0C30:  CALL   021A
.................... 	ms25(); 
0C34:  CALL   024A
.................... 	fputc(ARG_THREE,EVR); 
0C38:  MOVLW  44
0C3A:  CALL   021A
.................... 	ms25(); 
0C3E:  CALL   024A
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
0C42:  BCF    F92.0
0C44:  BSF    F89.0
.................... 	if (kbhit()) rec_GP3 = fgetc(EVR); 
0C46:  BTFSS  F9E.5
0C48:  BRA    0C52
0C4A:  BTFSS  F9E.5
0C4C:  BRA    0C4A
0C4E:  MOVFF  FAE,7B
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
0C52:  BCF    F92.0
0C54:  BCF    F89.0
.................... 	if (rec_GP3 == STS_SIMILAR){ 
0C56:  MOVF   7B,W
0C58:  SUBLW  73
0C5A:  BNZ   0CC6
.................... 		fputc(ARG_ACK,EVR); 
0C5C:  MOVLW  20
0C5E:  CALL   021A
.................... 		ms25(); 
0C62:  CALL   024A
.................... 		rec_GP3 = NUL; 
0C66:  CLRF   7B
.................... 		rec_GP3 = fgetc(EVR); 
0C68:  BTFSS  F9E.5
0C6A:  BRA    0C68
0C6C:  MOVFF  FAE,7B
.................... 		cmd_GP3 = rec_GP3 - ARG_ZERO; 
0C70:  MOVLW  41
0C72:  SUBWF  7B,W
0C74:  MOVWF  7C
.................... 		switch (cmd_GP3){ 
0C76:  MOVF   7C,W
0C78:  BZ    0CA4
0C7A:  XORLW  01
0C7C:  BZ    0CA6
0C7E:  XORLW  03
0C80:  BZ    0CAE
0C82:  XORLW  01
0C84:  BZ    0CB0
0C86:  XORLW  07
0C88:  BZ    0CB2
0C8A:  XORLW  01
0C8C:  BZ    0CB4
0C8E:  XORLW  03
0C90:  BZ    0CB6
0C92:  XORLW  01
0C94:  BZ    0CB8
0C96:  XORLW  0F
0C98:  BZ    0CBA
0C9A:  XORLW  01
0C9C:  BZ    0CBC
0C9E:  XORLW  03
0CA0:  BZ    0CBE
0CA2:  BRA    0CC0
.................... 			case G3_ZERO: 
.................... 				break; 
0CA4:  BRA    0CC4
.................... 			case G3_ONE: 
.................... 				blinkA0(1); 
0CA6:  MOVLW  01
0CA8:  MOVWF  7D
0CAA:  RCALL  092E
.................... 				break; 
0CAC:  BRA    0CC4
.................... 			case G3_TWO: 
.................... 				break; 
0CAE:  BRA    0CC4
.................... 			case G3_THREE: 
.................... 				break; 
0CB0:  BRA    0CC4
.................... 			case G3_FOUR: 
.................... 				break; 
0CB2:  BRA    0CC4
.................... 			case G3_FIVE: 
.................... 				break; 
0CB4:  BRA    0CC4
.................... 			case G3_SIX: 
.................... 				break; 
0CB6:  BRA    0CC4
.................... 			case G3_SEVEN: 
.................... 				break; 
0CB8:  BRA    0CC4
.................... 			case G3_EIGHT: 
.................... 				break; 
0CBA:  BRA    0CC4
.................... 			case G3_NINE: 
.................... 				break; 
0CBC:  BRA    0CC4
.................... 			case G3_TEN: 
.................... 				break; 
0CBE:  BRA    0CC4
.................... 			default:		rec_GP3 = STS_SIMILAR; 
0CC0:  MOVLW  73
0CC2:  MOVWF  7B
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
0CC4:  BRA    0CD4
.................... 	if (rec_GP3 == STS_TIMEOUT){ 
0CC6:  MOVF   7B,W
0CC8:  SUBLW  74
0CCA:  BNZ   0CCE
.................... 		break; 
.................... 	}else 
0CCC:  BRA    0CD4
.................... 	if (rec_GP3 == STS_ERROR){ 
0CCE:  MOVF   7B,W
0CD0:  SUBLW  65
0CD2:  BNZ   0CD4
.................... 		break; 
.................... 	} 
0CD4:  GOTO   0D42 (RETURN)
.................... } 
.................... void playback(int _playback){		//plays back custom sound 
*
0366:  CLRF   7C
.................... 	char _rec_play = NUL; 
.................... 	switch (_playback){ 
0368:  MOVF   7B,W
036A:  ADDLW  E6
036C:  BTFSC  FD8.0
036E:  BRA    0820
0370:  ADDLW  1A
0372:  GOTO   0824
.................... 		case BEEP: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0376:  MOVF   7C,W
0378:  SUBLW  6F
037A:  BZ    03A2
.................... 				fputc(CMD_PLAY_SX,EVR); 
037C:  MOVLW  77
037E:  RCALL  021A
.................... 				ms25(); 
0380:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0382:  MOVLW  41
0384:  RCALL  021A
.................... 				ms25(); 
0386:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0388:  MOVLW  41
038A:  RCALL  021A
.................... 				ms25(); 
038C:  RCALL  024A
.................... 				fputc(ARG_FIFTEEN,EVR); 
038E:  MOVLW  50
0390:  RCALL  021A
.................... 				ms25();  
0392:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0394:  BTFSS  F9E.5
0396:  BRA    03A0
0398:  BTFSS  F9E.5
039A:  BRA    0398
039C:  MOVFF  FAE,7C
03A0:  BRA    0376
.................... 			} 
.................... 			break; 
03A2:  BRA    0820
.................... 		case SND_zero: 
.................... 			while (_rec_play != STS_SUCCESS){ 
03A4:  MOVF   7C,W
03A6:  SUBLW  6F
03A8:  BZ    03D0
.................... 				fputc(CMD_PLAY_SX,EVR); 
03AA:  MOVLW  77
03AC:  RCALL  021A
.................... 				ms25(); 
03AE:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
03B0:  MOVLW  41
03B2:  RCALL  021A
.................... 				ms25(); 
03B4:  RCALL  024A
.................... 				fputc(ARG_ONE,EVR); 
03B6:  MOVLW  42
03B8:  RCALL  021A
.................... 				ms25(); 
03BA:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
03BC:  MOVLW  48
03BE:  RCALL  021A
.................... 				ms25(); 
03C0:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
03C2:  BTFSS  F9E.5
03C4:  BRA    03CE
03C6:  BTFSS  F9E.5
03C8:  BRA    03C6
03CA:  MOVFF  FAE,7C
03CE:  BRA    03A4
.................... 			} 
.................... 			break; 
03D0:  BRA    0820
.................... 		case SND_one: 
.................... 			while (_rec_play != STS_SUCCESS){ 
03D2:  MOVF   7C,W
03D4:  SUBLW  6F
03D6:  BZ    03FE
.................... 				fputc(CMD_PLAY_SX,EVR); 
03D8:  MOVLW  77
03DA:  RCALL  021A
.................... 				ms25(); 
03DC:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
03DE:  MOVLW  41
03E0:  RCALL  021A
.................... 				ms25(); 
03E2:  RCALL  024A
.................... 				fputc(ARG_TWO,EVR); 
03E4:  MOVLW  43
03E6:  RCALL  021A
.................... 				ms25(); 
03E8:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
03EA:  MOVLW  48
03EC:  RCALL  021A
.................... 				ms25(); 
03EE:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
03F0:  BTFSS  F9E.5
03F2:  BRA    03FC
03F4:  BTFSS  F9E.5
03F6:  BRA    03F4
03F8:  MOVFF  FAE,7C
03FC:  BRA    03D2
.................... 			} 
.................... 			break; 
03FE:  BRA    0820
.................... 		case SND_two: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0400:  MOVF   7C,W
0402:  SUBLW  6F
0404:  BZ    042C
.................... 				fputc(CMD_PLAY_SX,EVR); 
0406:  MOVLW  77
0408:  RCALL  021A
.................... 				ms25(); 
040A:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
040C:  MOVLW  41
040E:  RCALL  021A
.................... 				ms25(); 
0410:  RCALL  024A
.................... 				fputc(ARG_THREE,EVR); 
0412:  MOVLW  44
0414:  RCALL  021A
.................... 				ms25(); 
0416:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0418:  MOVLW  48
041A:  RCALL  021A
.................... 				ms25(); 
041C:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
041E:  BTFSS  F9E.5
0420:  BRA    042A
0422:  BTFSS  F9E.5
0424:  BRA    0422
0426:  MOVFF  FAE,7C
042A:  BRA    0400
.................... 			} 
.................... 			break; 
042C:  BRA    0820
.................... 		case SND_three: 
.................... 			while (_rec_play != STS_SUCCESS){ 
042E:  MOVF   7C,W
0430:  SUBLW  6F
0432:  BZ    045A
.................... 				fputc(CMD_PLAY_SX,EVR); 
0434:  MOVLW  77
0436:  RCALL  021A
.................... 				ms25(); 
0438:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
043A:  MOVLW  41
043C:  RCALL  021A
.................... 				ms25(); 
043E:  RCALL  024A
.................... 				fputc(ARG_FOUR,EVR); 
0440:  MOVLW  45
0442:  RCALL  021A
.................... 				ms25(); 
0444:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0446:  MOVLW  48
0448:  RCALL  021A
.................... 				ms25(); 
044A:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
044C:  BTFSS  F9E.5
044E:  BRA    0458
0450:  BTFSS  F9E.5
0452:  BRA    0450
0454:  MOVFF  FAE,7C
0458:  BRA    042E
.................... 			} 
.................... 			break; 
045A:  BRA    0820
.................... 		case SND_four: 
.................... 			while (_rec_play != STS_SUCCESS){ 
045C:  MOVF   7C,W
045E:  SUBLW  6F
0460:  BZ    0488
.................... 				fputc(CMD_PLAY_SX,EVR); 
0462:  MOVLW  77
0464:  RCALL  021A
.................... 				ms25(); 
0466:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0468:  MOVLW  41
046A:  RCALL  021A
.................... 				ms25(); 
046C:  RCALL  024A
.................... 				fputc(ARG_FIVE,EVR); 
046E:  MOVLW  46
0470:  RCALL  021A
.................... 				ms25(); 
0472:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0474:  MOVLW  48
0476:  RCALL  021A
.................... 				ms25(); 
0478:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
047A:  BTFSS  F9E.5
047C:  BRA    0486
047E:  BTFSS  F9E.5
0480:  BRA    047E
0482:  MOVFF  FAE,7C
0486:  BRA    045C
.................... 			} 
.................... 			break; 
0488:  BRA    0820
.................... 		case SND_five: 
.................... 			while (_rec_play != STS_SUCCESS){ 
048A:  MOVF   7C,W
048C:  SUBLW  6F
048E:  BZ    04B6
.................... 				fputc(CMD_PLAY_SX,EVR); 
0490:  MOVLW  77
0492:  RCALL  021A
.................... 				ms25(); 
0494:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0496:  MOVLW  41
0498:  RCALL  021A
.................... 				ms25(); 
049A:  RCALL  024A
.................... 				fputc(ARG_SIX,EVR); 
049C:  MOVLW  47
049E:  RCALL  021A
.................... 				ms25(); 
04A0:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
04A2:  MOVLW  48
04A4:  RCALL  021A
.................... 				ms25(); 
04A6:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
04A8:  BTFSS  F9E.5
04AA:  BRA    04B4
04AC:  BTFSS  F9E.5
04AE:  BRA    04AC
04B0:  MOVFF  FAE,7C
04B4:  BRA    048A
.................... 			} 
.................... 			break; 
04B6:  BRA    0820
.................... 		case SND_six: 
.................... 			while (_rec_play != STS_SUCCESS){ 
04B8:  MOVF   7C,W
04BA:  SUBLW  6F
04BC:  BZ    04E4
.................... 				fputc(CMD_PLAY_SX,EVR); 
04BE:  MOVLW  77
04C0:  RCALL  021A
.................... 				ms25(); 
04C2:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
04C4:  MOVLW  41
04C6:  RCALL  021A
.................... 				ms25(); 
04C8:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
04CA:  MOVLW  48
04CC:  RCALL  021A
.................... 				ms25(); 
04CE:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
04D0:  MOVLW  48
04D2:  RCALL  021A
.................... 				ms25(); 
04D4:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
04D6:  BTFSS  F9E.5
04D8:  BRA    04E2
04DA:  BTFSS  F9E.5
04DC:  BRA    04DA
04DE:  MOVFF  FAE,7C
04E2:  BRA    04B8
.................... 			} 
.................... 			break; 
04E4:  BRA    0820
.................... 		case SND_seven: 
.................... 			while (_rec_play != STS_SUCCESS){ 
04E6:  MOVF   7C,W
04E8:  SUBLW  6F
04EA:  BZ    0512
.................... 				fputc(CMD_PLAY_SX,EVR); 
04EC:  MOVLW  77
04EE:  RCALL  021A
.................... 				ms25(); 
04F0:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
04F2:  MOVLW  41
04F4:  RCALL  021A
.................... 				ms25(); 
04F6:  RCALL  024A
.................... 				fputc(ARG_EIGHT,EVR); 
04F8:  MOVLW  49
04FA:  RCALL  021A
.................... 				ms25(); 
04FC:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
04FE:  MOVLW  48
0500:  RCALL  021A
.................... 				ms25(); 
0502:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0504:  BTFSS  F9E.5
0506:  BRA    0510
0508:  BTFSS  F9E.5
050A:  BRA    0508
050C:  MOVFF  FAE,7C
0510:  BRA    04E6
.................... 			} 
.................... 			break; 
0512:  BRA    0820
.................... 		case SND_eight: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0514:  MOVF   7C,W
0516:  SUBLW  6F
0518:  BZ    0540
.................... 				fputc(CMD_PLAY_SX,EVR); 
051A:  MOVLW  77
051C:  RCALL  021A
.................... 				ms25(); 
051E:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0520:  MOVLW  41
0522:  RCALL  021A
.................... 				ms25(); 
0524:  RCALL  024A
.................... 				fputc(ARG_NINE,EVR); 
0526:  MOVLW  4A
0528:  RCALL  021A
.................... 				ms25(); 
052A:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
052C:  MOVLW  48
052E:  RCALL  021A
.................... 				ms25(); 
0530:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0532:  BTFSS  F9E.5
0534:  BRA    053E
0536:  BTFSS  F9E.5
0538:  BRA    0536
053A:  MOVFF  FAE,7C
053E:  BRA    0514
.................... 			} 
.................... 			break; 
0540:  BRA    0820
.................... 		case SND_nine: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0542:  MOVF   7C,W
0544:  SUBLW  6F
0546:  BZ    056E
.................... 				fputc(CMD_PLAY_SX,EVR); 
0548:  MOVLW  77
054A:  RCALL  021A
.................... 				ms25(); 
054C:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
054E:  MOVLW  41
0550:  RCALL  021A
.................... 				ms25(); 
0552:  RCALL  024A
.................... 				fputc(ARG_TEN,EVR); 
0554:  MOVLW  4B
0556:  RCALL  021A
.................... 				ms25(); 
0558:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
055A:  MOVLW  48
055C:  RCALL  021A
.................... 				ms25(); 
055E:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0560:  BTFSS  F9E.5
0562:  BRA    056C
0564:  BTFSS  F9E.5
0566:  BRA    0564
0568:  MOVFF  FAE,7C
056C:  BRA    0542
.................... 			} 
.................... 			break; 
056E:  BRA    0820
.................... 		case SND_please_say_a_command: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0570:  MOVF   7C,W
0572:  SUBLW  6F
0574:  BZ    059C
.................... 				fputc(CMD_PLAY_SX,EVR); 
0576:  MOVLW  77
0578:  RCALL  021A
.................... 				ms25(); 
057A:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
057C:  MOVLW  41
057E:  RCALL  021A
.................... 				ms25(); 
0580:  RCALL  024A
.................... 				fputc(ARG_ELEVEN,EVR); 
0582:  MOVLW  4C
0584:  RCALL  021A
.................... 				ms25(); 
0586:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0588:  MOVLW  48
058A:  RCALL  021A
.................... 				ms25(); 
058C:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
058E:  BTFSS  F9E.5
0590:  BRA    059A
0592:  BTFSS  F9E.5
0594:  BRA    0592
0596:  MOVFF  FAE,7C
059A:  BRA    0570
.................... 			} 
.................... 			break; 
059C:  BRA    0820
.................... 		case SND_hello_please_say_a_command: 
.................... 			while (_rec_play != STS_SUCCESS){ 
059E:  MOVF   7C,W
05A0:  SUBLW  6F
05A2:  BZ    05CA
.................... 				fputc(CMD_PLAY_SX,EVR); 
05A4:  MOVLW  77
05A6:  RCALL  021A
.................... 				ms25(); 
05A8:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
05AA:  MOVLW  41
05AC:  RCALL  021A
.................... 				ms25(); 
05AE:  RCALL  024A
.................... 				fputc(ARG_TWELVE,EVR); 
05B0:  MOVLW  4D
05B2:  RCALL  021A
.................... 				ms25(); 
05B4:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
05B6:  MOVLW  48
05B8:  RCALL  021A
.................... 				ms25(); 
05BA:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
05BC:  BTFSS  F9E.5
05BE:  BRA    05C8
05C0:  BTFSS  F9E.5
05C2:  BRA    05C0
05C4:  MOVFF  FAE,7C
05C8:  BRA    059E
.................... 			} 
.................... 			break; 
05CA:  BRA    0820
.................... 		case SND_who_would_you_like_to_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
05CC:  MOVF   7C,W
05CE:  SUBLW  6F
05D0:  BZ    05F8
.................... 				fputc(CMD_PLAY_SX,EVR); 
05D2:  MOVLW  77
05D4:  RCALL  021A
.................... 				ms25(); 
05D6:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
05D8:  MOVLW  41
05DA:  RCALL  021A
.................... 				ms25(); 
05DC:  RCALL  024A
.................... 				fputc(ARG_THIRTEEN,EVR); 
05DE:  MOVLW  4E
05E0:  RCALL  021A
.................... 				ms25(); 
05E2:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
05E4:  MOVLW  48
05E6:  RCALL  021A
.................... 				ms25(); 
05E8:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
05EA:  BTFSS  F9E.5
05EC:  BRA    05F6
05EE:  BTFSS  F9E.5
05F0:  BRA    05EE
05F2:  MOVFF  FAE,7C
05F6:  BRA    05CC
.................... 			} 
.................... 			break; 
05F8:  BRA    0820
.................... 		case SND_calling: 
.................... 			while (_rec_play != STS_SUCCESS){ 
05FA:  MOVF   7C,W
05FC:  SUBLW  6F
05FE:  BZ    0626
.................... 				fputc(CMD_PLAY_SX,EVR); 
0600:  MOVLW  77
0602:  RCALL  021A
.................... 				ms25(); 
0604:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0606:  MOVLW  41
0608:  RCALL  021A
.................... 				ms25(); 
060A:  RCALL  024A
.................... 				fputc(ARG_FOURTEEN,EVR); 
060C:  MOVLW  4F
060E:  RCALL  021A
.................... 				ms25(); 
0610:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0612:  MOVLW  48
0614:  RCALL  021A
.................... 				ms25(); 
0616:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0618:  BTFSS  F9E.5
061A:  BRA    0624
061C:  BTFSS  F9E.5
061E:  BRA    061C
0620:  MOVFF  FAE,7C
0624:  BRA    05FA
.................... 			} 
.................... 			break; 
0626:  BRA    0820
.................... 		case SND_doctor: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0628:  MOVF   7C,W
062A:  SUBLW  6F
062C:  BZ    0654
.................... 				fputc(CMD_PLAY_SX,EVR); 
062E:  MOVLW  77
0630:  RCALL  021A
.................... 				ms25(); 
0632:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0634:  MOVLW  41
0636:  RCALL  021A
.................... 				ms25(); 
0638:  RCALL  024A
.................... 				fputc(ARG_FIFTEEN,EVR); 
063A:  MOVLW  50
063C:  RCALL  021A
.................... 				ms25(); 
063E:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0640:  MOVLW  48
0642:  RCALL  021A
.................... 				ms25(); 
0644:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0646:  BTFSS  F9E.5
0648:  BRA    0652
064A:  BTFSS  F9E.5
064C:  BRA    064A
064E:  MOVFF  FAE,7C
0652:  BRA    0628
.................... 			} 
.................... 			break; 
0654:  BRA    0820
.................... 		case SND_say_send_to_place_the_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0656:  MOVF   7C,W
0658:  SUBLW  6F
065A:  BZ    0682
.................... 				fputc(CMD_PLAY_SX,EVR); 
065C:  MOVLW  77
065E:  RCALL  021A
.................... 				ms25(); 
0660:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0662:  MOVLW  41
0664:  RCALL  021A
.................... 				ms25(); 
0666:  RCALL  024A
.................... 				fputc(ARG_SIXTEEN,EVR); 
0668:  MOVLW  51
066A:  RCALL  021A
.................... 				ms25(); 
066C:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
066E:  MOVLW  48
0670:  RCALL  021A
.................... 				ms25(); 
0672:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0674:  BTFSS  F9E.5
0676:  BRA    0680
0678:  BTFSS  F9E.5
067A:  BRA    0678
067C:  MOVFF  FAE,7C
0680:  BRA    0656
.................... 			} 
.................... 			break; 
0682:  BRA    0820
.................... 		case SND_say_reject_to_reject_the_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0684:  MOVF   7C,W
0686:  SUBLW  6F
0688:  BZ    06B0
.................... 				fputc(CMD_PLAY_SX,EVR); 
068A:  MOVLW  77
068C:  RCALL  021A
.................... 				ms25(); 
068E:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0690:  MOVLW  41
0692:  RCALL  021A
.................... 				ms25(); 
0694:  RCALL  024A
.................... 				fputc(ARG_SEVENTEEN,EVR); 
0696:  MOVLW  52
0698:  RCALL  021A
.................... 				ms25(); 
069A:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
069C:  MOVLW  48
069E:  RCALL  021A
.................... 				ms25(); 
06A0:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
06A2:  BTFSS  F9E.5
06A4:  BRA    06AE
06A6:  BTFSS  F9E.5
06A8:  BRA    06A6
06AA:  MOVFF  FAE,7C
06AE:  BRA    0684
.................... 			} 
.................... 			break; 
06B0:  BRA    0820
.................... 		case SND_say_answer_to_answer_the_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
06B2:  MOVF   7C,W
06B4:  SUBLW  6F
06B6:  BZ    06DE
.................... 				fputc(CMD_PLAY_SX,EVR); 
06B8:  MOVLW  77
06BA:  RCALL  021A
.................... 				ms25(); 
06BC:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
06BE:  MOVLW  41
06C0:  RCALL  021A
.................... 				ms25(); 
06C2:  RCALL  024A
.................... 				fputc(ARG_EIGHTEEN,EVR); 
06C4:  MOVLW  53
06C6:  RCALL  021A
.................... 				ms25(); 
06C8:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
06CA:  MOVLW  48
06CC:  RCALL  021A
.................... 				ms25(); 
06CE:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
06D0:  BTFSS  F9E.5
06D2:  BRA    06DC
06D4:  BTFSS  F9E.5
06D6:  BRA    06D4
06D8:  MOVFF  FAE,7C
06DC:  BRA    06B2
.................... 			} 
.................... 			break; 
06DE:  BRA    0820
.................... 		case SND_say_end_to_cancel: 
.................... 			while (_rec_play != STS_SUCCESS){ 
06E0:  MOVF   7C,W
06E2:  SUBLW  6F
06E4:  BZ    070C
.................... 				fputc(CMD_PLAY_SX,EVR); 
06E6:  MOVLW  77
06E8:  RCALL  021A
.................... 				ms25(); 
06EA:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
06EC:  MOVLW  41
06EE:  RCALL  021A
.................... 				ms25(); 
06F0:  RCALL  024A
.................... 				fputc(ARG_NINETEEN,EVR); 
06F2:  MOVLW  54
06F4:  RCALL  021A
.................... 				ms25(); 
06F6:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
06F8:  MOVLW  48
06FA:  RCALL  021A
.................... 				ms25(); 
06FC:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
06FE:  BTFSS  F9E.5
0700:  BRA    070A
0702:  BTFSS  F9E.5
0704:  BRA    0702
0706:  MOVFF  FAE,7C
070A:  BRA    06E0
.................... 			} 
.................... 			break; 
070C:  BRA    0820
.................... 		case SND_turning_on_LED: 
.................... 			while (_rec_play != STS_SUCCESS){ 
070E:  MOVF   7C,W
0710:  SUBLW  6F
0712:  BZ    073A
.................... 				fputc(CMD_PLAY_SX,EVR); 
0714:  MOVLW  77
0716:  RCALL  021A
.................... 				ms25(); 
0718:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
071A:  MOVLW  41
071C:  RCALL  021A
.................... 				ms25(); 
071E:  RCALL  024A
.................... 				fputc(ARG_TWENTY,EVR); 
0720:  MOVLW  55
0722:  RCALL  021A
.................... 				ms25(); 
0724:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0726:  MOVLW  48
0728:  RCALL  021A
.................... 				ms25(); 
072A:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
072C:  BTFSS  F9E.5
072E:  BRA    0738
0730:  BTFSS  F9E.5
0732:  BRA    0730
0734:  MOVFF  FAE,7C
0738:  BRA    070E
.................... 			} 
.................... 			break; 
073A:  BRA    0820
.................... 		case SND_turning_on_light_bulb: 
.................... 			while (_rec_play != STS_SUCCESS){ 
073C:  MOVF   7C,W
073E:  SUBLW  6F
0740:  BZ    0768
.................... 				fputc(CMD_PLAY_SX,EVR); 
0742:  MOVLW  77
0744:  RCALL  021A
.................... 				ms25(); 
0746:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0748:  MOVLW  41
074A:  RCALL  021A
.................... 				ms25(); 
074C:  RCALL  024A
.................... 				fputc(ARG_TWENTYONE,EVR); 
074E:  MOVLW  56
0750:  RCALL  021A
.................... 				ms25(); 
0752:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0754:  MOVLW  48
0756:  RCALL  021A
.................... 				ms25(); 
0758:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
075A:  BTFSS  F9E.5
075C:  BRA    0766
075E:  BTFSS  F9E.5
0760:  BRA    075E
0762:  MOVFF  FAE,7C
0766:  BRA    073C
.................... 			} 
.................... 			break; 
0768:  BRA    0820
.................... 		case SND_turning_off_led: 
.................... 			while (_rec_play != STS_SUCCESS){ 
076A:  MOVF   7C,W
076C:  SUBLW  6F
076E:  BZ    0796
.................... 				fputc(CMD_PLAY_SX,EVR); 
0770:  MOVLW  77
0772:  RCALL  021A
.................... 				ms25(); 
0774:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0776:  MOVLW  41
0778:  RCALL  021A
.................... 				ms25(); 
077A:  RCALL  024A
.................... 				fputc(ARG_TWENTYTWO,EVR); 
077C:  MOVLW  57
077E:  RCALL  021A
.................... 				ms25(); 
0780:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
0782:  MOVLW  48
0784:  RCALL  021A
.................... 				ms25(); 
0786:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0788:  BTFSS  F9E.5
078A:  BRA    0794
078C:  BTFSS  F9E.5
078E:  BRA    078C
0790:  MOVFF  FAE,7C
0794:  BRA    076A
.................... 			} 
.................... 			break; 
0796:  BRA    0820
.................... 		case SND_turning_off_light_bulb: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0798:  MOVF   7C,W
079A:  SUBLW  6F
079C:  BZ    07C4
.................... 				fputc(CMD_PLAY_SX,EVR); 
079E:  MOVLW  77
07A0:  RCALL  021A
.................... 				ms25(); 
07A2:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
07A4:  MOVLW  41
07A6:  RCALL  021A
.................... 				ms25(); 
07A8:  RCALL  024A
.................... 				fputc(ARG_TWENTYTHREE,EVR); 
07AA:  MOVLW  58
07AC:  RCALL  021A
.................... 				ms25(); 
07AE:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
07B0:  MOVLW  48
07B2:  RCALL  021A
.................... 				ms25(); 
07B4:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
07B6:  BTFSS  F9E.5
07B8:  BRA    07C2
07BA:  BTFSS  F9E.5
07BC:  BRA    07BA
07BE:  MOVFF  FAE,7C
07C2:  BRA    0798
.................... 			} 
.................... 			break;  
07C4:  BRA    0820
.................... 		case SND_you_have_an_incoming_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
07C6:  MOVF   7C,W
07C8:  SUBLW  6F
07CA:  BZ    07F2
.................... 				fputc(CMD_PLAY_SX,EVR); 
07CC:  MOVLW  77
07CE:  RCALL  021A
.................... 				ms25(); 
07D0:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
07D2:  MOVLW  41
07D4:  RCALL  021A
.................... 				ms25(); 
07D6:  RCALL  024A
.................... 				fputc(ARG_TWENTYFOUR,EVR); 
07D8:  MOVLW  59
07DA:  RCALL  021A
.................... 				ms25(); 
07DC:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
07DE:  MOVLW  48
07E0:  RCALL  021A
.................... 				ms25(); 
07E2:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
07E4:  BTFSS  F9E.5
07E6:  BRA    07F0
07E8:  BTFSS  F9E.5
07EA:  BRA    07E8
07EC:  MOVFF  FAE,7C
07F0:  BRA    07C6
.................... 			} 
.................... 			break; 
07F2:  BRA    0820
.................... 		case SND_command_accepted: 
.................... 			while (_rec_play != STS_SUCCESS){ 
07F4:  MOVF   7C,W
07F6:  SUBLW  6F
07F8:  BZ    0820
.................... 				fputc(CMD_PLAY_SX,EVR); 
07FA:  MOVLW  77
07FC:  RCALL  021A
.................... 				ms25(); 
07FE:  RCALL  024A
.................... 				fputc(ARG_ZERO,EVR); 
0800:  MOVLW  41
0802:  RCALL  021A
.................... 				ms25(); 
0804:  RCALL  024A
.................... 				fputc(ARG_TWENTYFIVE,EVR); 
0806:  MOVLW  5A
0808:  RCALL  021A
.................... 				ms25(); 
080A:  RCALL  024A
.................... 				fputc(ARG_SEVEN,EVR); 
080C:  MOVLW  48
080E:  RCALL  021A
.................... 				ms25(); 
0810:  RCALL  024A
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0812:  BTFSS  F9E.5
0814:  BRA    081E
0816:  BTFSS  F9E.5
0818:  BRA    0816
081A:  MOVFF  FAE,7C
081E:  BRA    07F4
.................... 			} 
.................... 			break; 
.................... 	} 
0820:  GOTO   0D08 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... //                       =================                       // 
.................... //=======================I N T E R U P T S=======================// 
.................... //                       =================                       // 
.................... #DEVICE HIGH_INTS=TRUE 
.................... volatile unsigned int call_flag = FALSE; 
.................... #define RX_SIZE 20 
.................... volatile char rx_buff[RX_SIZE]; 
.................... volatile char temp; 
.................... volatile int serial_idx = 0; 
.................... volatile int command_ready = FALSE; 
.................... #INT_EXT HIGH 
.................... void EXT_isr(void){ 
.................... 	temp = fgetc(GSM); 
*
01E4:  BRA    01A0
01E6:  MOVFF  01,78
.................... //if we got a CR, then the command is completed 
.................... 	if ((temp == CR) && (serial_idx > 1)) command_ready = TRUE; 
01EA:  MOVF   78,W
01EC:  SUBLW  0D
01EE:  BNZ   01FA
01F0:  MOVF   79,W
01F2:  SUBLW  01
01F4:  BC    01FA
01F6:  MOVLW  01
01F8:  MOVWF  7A
.................... //save the character to the receive buffer 
.................... 	rx_buff[serial_idx] = temp; 
01FA:  CLRF   03
01FC:  MOVF   79,W
01FE:  ADDLW  64
0200:  MOVWF  FE9
0202:  MOVLW  00
0204:  ADDWFC 03,W
0206:  MOVWF  FEA
0208:  MOVFF  78,FEF
.................... 	++serial_idx; 
020C:  INCF   79,F
.................... //if the command is ready, then reset the buffer 
.................... 	if (command_ready == TRUE) serial_idx = 0; 
020E:  DECFSZ 7A,W
0210:  BRA    0214
0212:  CLRF   79
0214:  BCF    FF2.1
0216:  GOTO   010A
.................... } 
....................  
.................... void bgets(char* s, unsigned int8 max){ 
.................... 	unsigned char _c; 
.................... 	unsigned int8 len; 
.................... 	unsigned int8 read_idx; 
.................... 	unsigned int eos = 0; 
....................  
.................... 	--max; 
.................... 	len = 0; 
.................... 	read_idx = 0; 
.................... 	do{		 
.................... 		_c = rx_buff[read_idx]; 
.................... 		if ((_c == CR) && (read_idx > 1)){ 
.................... 			eos = 1; 
.................... 			s[len] = _c; 
.................... 		} 
.................... 		++read_idx; 
.................... 		++len; 
.................... 	}while(!eos); 
.................... 	s[len] = 0; 
.................... 	len = 0; 
.................... 	serial_idx = 0; 
.................... 	read_idx = 0; 
.................... } 
....................  
....................  
....................  
....................  
.................... //                    ========================                   // 
.................... //====================S T A T E  M A C H I N E===================// 
.................... //                    ========================                   // 
.................... void StateMachine(void){ 
.................... 	switch (current_state){ 
*
0CD8:  MOVF   62,W
0CDA:  XORLW  00
0CDC:  BZ    0CFC
0CDE:  XORLW  01
0CE0:  BZ    0D0E
0CE2:  XORLW  03
0CE4:  BZ    0D18
0CE6:  XORLW  01
0CE8:  BZ    0D22
0CEA:  XORLW  07
0CEC:  BZ    0D2C
0CEE:  XORLW  01
0CF0:  BZ    0D36
0CF2:  XORLW  03
0CF4:  BZ    0D40
0CF6:  XORLW  01
0CF8:  BZ    0D4A
0CFA:  BRA    0D4C
.................... 		case S_RESET: 
.................... 				wake_EVR(); 
0CFC:  GOTO   031A
.................... 				playback(SND_hello_please_say_a_command); 
0D00:  MOVLW  0C
0D02:  MOVWF  7B
0D04:  GOTO   0366
.................... 				current_state = S_GP1; 
0D08:  MOVLW  04
0D0A:  MOVWF  62
.................... 			break; 
0D0C:  BRA    0D4E
.................... 		case S_WS1: 
.................... 				listenWS1(); 
0D0E:  BRA    0894
.................... 				blinkA0(1);//indicate a change of state resulting from the above function 
0D10:  MOVLW  01
0D12:  MOVWF  7D
0D14:  RCALL  092E
.................... 			break; 
0D16:  BRA    0D4E
.................... 		case S_WS2: 
.................... 				listenWS2(); 
0D18:  BRA    0950
.................... 				blinkA0(1);//indicate a change of state resulting from the above function 
0D1A:  MOVLW  01
0D1C:  MOVWF  7D
0D1E:  RCALL  092E
.................... 			break; 
0D20:  BRA    0D4E
.................... 		case S_WS3: 
.................... 				listenWS3(); 
0D22:  BRA    09CE
.................... 				blinkA0(1);//indicate a change of state resulting from the above function 
0D24:  MOVLW  01
0D26:  MOVWF  7D
0D28:  RCALL  092E
.................... 			break; 
0D2A:  BRA    0D4E
.................... 		case S_GP1: 
.................... 				listenGP1(); 
0D2C:  BRA    0AD6
.................... 				blinkA0(1);//indicate a change of state resulting from the above function 
0D2E:  MOVLW  01
0D30:  MOVWF  7D
0D32:  RCALL  092E
.................... 			break; 
0D34:  BRA    0D4E
.................... 		case S_GP2: 
.................... 				listenGP2(); 
0D36:  BRA    0B8E
.................... 				blinkA0(1);//indicate a change of state resulting from the above function 
0D38:  MOVLW  01
0D3A:  MOVWF  7D
0D3C:  RCALL  092E
.................... 			break; 
0D3E:  BRA    0D4E
.................... 		case S_GP3: 
.................... 				listenGP3(); 
0D40:  BRA    0C2A
.................... 				blinkA0(1);//indicate a change of state resulting from the above function 
0D42:  MOVLW  01
0D44:  MOVWF  7D
0D46:  RCALL  092E
.................... 			break; 
0D48:  BRA    0D4E
.................... 		case S_RECEIVE_CALL: 
.................... 				 
.................... 			break; 
0D4A:  BRA    0D4E
.................... 		default: 
.................... 			current_state = S_RESET; 
0D4C:  CLRF   62
.................... 			break; 
.................... 		 
.................... 	} 
0D4E:  GOTO   0E14 (RETURN)
.................... } 
.................... //<<end of STATE MACHINE 
....................  
....................  
.................... //                   ========================                    // 
.................... //===================M A I N  F U N C T I O N====================// 
.................... //                   ========================                    // 
.................... void main(){ 
0D52:  CLRF   FF8
0D54:  BSF    FD0.7
0D56:  BSF    07.7
0D58:  BCF    FB8.3
0D5A:  MOVLW  40
0D5C:  MOVWF  FAF
0D5E:  MOVLW  A6
0D60:  MOVWF  FAC
0D62:  MOVLW  90
0D64:  MOVWF  FAB
0D66:  BCF    F93.1
0D68:  BSF    F8A.1
0D6A:  BCF    F92.4
0D6C:  BSF    F89.4
0D6E:  CLRF   35
0D70:  CLRF   34
0D72:  CLRF   36
0D74:  CLRF   62
0D76:  CLRF   63
0D78:  CLRF   79
0D7A:  CLRF   7A
0D7C:  MOVF   FC1,W
0D7E:  ANDLW  C0
0D80:  IORLW  0F
0D82:  MOVWF  FC1
0D84:  MOVLW  07
0D86:  MOVWF  FB4
0D88:  BRA    0DBE
0D8A:  DATA 02,00
0D8C:  DATA 2E,00
0D8E:  DATA 00,2B
0D90:  DATA 00,37
0D92:  DATA 41,54
0D94:  DATA 0D,0A
0D96:  DATA 00,41
0D98:  DATA 54,26
0D9A:  DATA 57,0D
0D9C:  DATA 0A,00
0D9E:  DATA 41,54
0DA0:  DATA 45,30
0DA2:  DATA 0D,0A
0DA4:  DATA 00,41
0DA6:  DATA 54,2B
0DA8:  DATA 43,4D
0DAA:  DATA 47,46
0DAC:  DATA 3D,31
0DAE:  DATA 0D,0A
0DB0:  DATA 00,41
0DB2:  DATA 54,48
0DB4:  DATA 0D,0A
0DB6:  DATA 00,41
0DB8:  DATA 54,41
0DBA:  DATA 0D,0A
0DBC:  DATA 00,00
0DBE:  MOVLW  00
0DC0:  MOVWF  FF8
0DC2:  MOVLW  0D
0DC4:  MOVWF  FF7
0DC6:  MOVLW  8A
0DC8:  MOVWF  FF6
0DCA:  TBLRD*+
0DCC:  MOVF   FF5,W
0DCE:  MOVWF  00
0DD0:  XORLW  00
0DD2:  BZ    0DFA
0DD4:  TBLRD*+
0DD6:  MOVF   FF5,W
0DD8:  MOVWF  01
0DDA:  BTFSC  FE8.7
0DDC:  BRA    0DE8
0DDE:  ANDLW  0F
0DE0:  MOVWF  FEA
0DE2:  TBLRD*+
0DE4:  MOVFF  FF5,FE9
0DE8:  BTFSC  01.6
0DEA:  TBLRD*+
0DEC:  BTFSS  01.6
0DEE:  TBLRD*+
0DF0:  MOVFF  FF5,FEE
0DF4:  DCFSNZ 00,F
0DF6:  BRA    0DCA
0DF8:  BRA    0DEC
0DFA:  CLRF   FF8
.................... 	//char k = NUL; 
.................... 	 
.................... 	halt();					//stop or wake up device 
0DFC:  GOTO   029A
.................... 	setLang(ARG_ZERO);		//set the language to english 
0E00:  MOVLW  41
0E02:  MOVWF  7B
0E04:  GOTO   02C2
.................... 	setTimeout(ARG_FIVE);	//set the timeout for 5 seconds 
0E08:  MOVLW  46
0E0A:  MOVWF  7B
0E0C:  GOTO   02EE
.................... 	 
....................  
.................... 	current_state = S_RESET; 
0E10:  CLRF   62
.................... 	while (TRUE){ 
.................... 		StateMachine(); 
0E12:  BRA    0CD8
0E14:  BRA    0E12
.................... 	} 
.................... } 
.................... //<<end of MAIN FUNCTION 
0E16:  BRA    0E16
.................... //Hare Krsna Hare Krsna Krsna Krsna Hare Hare Hare Rama Hare Rama Rama Rama Hare Hare// 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

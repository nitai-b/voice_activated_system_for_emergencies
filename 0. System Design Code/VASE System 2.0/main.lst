CCS PCH C Compiler, Version 5.059, 5967               07-Apr-17 13:07

               Filename:   C:\Users\nitai\OneDrive\Documents\Year 3- ECNG 3020- Special Project\2. Designs\0. System Design Code\VASE System 2.0\main.lst

               ROM used:   3878 bytes (6%)
                           Largest free fragment is 60822
               RAM used:   116 (3%) at main() level
                           128 (3%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 30

*
0000:  GOTO   0A40
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   0214
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   021E
006C:  BTFSS  FF2.4
006E:  GOTO   0078
0072:  BTFSC  FF2.1
0074:  GOTO   00DE
0078:  BTFSS  FF0.3
007A:  GOTO   0084
007E:  BTFSC  FF0.0
0080:  GOTO   014A
0084:  BTFSS  FF0.4
0086:  GOTO   0090
008A:  BTFSC  FF0.1
008C:  GOTO   019E
0090:  MOVFF  0E,00
0094:  MOVFF  0F,01
0098:  MOVFF  10,02
009C:  MOVFF  11,03
00A0:  MOVFF  0C,FE9
00A4:  MOVFF  07,FEA
00A8:  BSF    07.7
00AA:  MOVFF  08,FE1
00AE:  MOVFF  09,FE2
00B2:  MOVFF  0A,FD9
00B6:  MOVFF  0B,FDA
00BA:  MOVFF  12,FF3
00BE:  MOVFF  13,FF4
00C2:  MOVFF  14,FFA
00C6:  MOVFF  15,FF5
00CA:  MOVFF  16,FF6
00CE:  MOVFF  17,FF7
00D2:  MOVF   04,W
00D4:  MOVFF  06,FE0
00D8:  MOVFF  05,FD8
00DC:  RETFIE 0
.................... //                    =======================                    // 
.................... //====================I N T R O D U C T I O N====================// 
.................... //                    =======================                    // 
.................... /*		Author:		Mr. Nitai Barran 
....................  *		Supervisor: Prof. Stephan J.G. Gift 
....................  *		System:		Voice Activated System for Emergencies 
....................  */ 
.................... //<<end of INTRODUCTION 
.................... #include <18f4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
*
012A:  TBLRD*+
012C:  MOVF   FF5,F
012E:  BZ    0148
0130:  MOVFF  FF6,7D
0134:  MOVFF  FF7,7E
0138:  MOVFF  FF5,7F
013C:  RCALL  00EA
013E:  MOVFF  7D,FF6
0142:  MOVFF  7E,FF7
0146:  BRA    012A
0148:  RETURN 0
*
018C:  DATA 41,54
018E:  DATA 44,2B
0190:  DATA 31,38
0192:  DATA 36,38
0194:  DATA 36,38
0196:  DATA 32,32
0198:  DATA 30,31
019A:  DATA 35,3B
019C:  DATA 00,00
*
0208:  DATA 41,54
020A:  DATA 41,0D
020C:  DATA 0A,00
020E:  DATA 41,54
0210:  DATA 48,0D
0212:  DATA 0A,00
*
0250:  DATA 41,54
0252:  DATA 44,2B
0254:  DATA 31,38
0256:  DATA 36,38
0258:  DATA 36,38
025A:  DATA 32,32
025C:  DATA 30,31
025E:  DATA 35,3B
0260:  DATA 00,00
0262:  MOVF   FEF,F
0264:  BZ    0290
0266:  MOVFF  FEA,73
026A:  MOVFF  FE9,72
026E:  CLRF   19
0270:  BTFSC  FF2.7
0272:  BSF    19.7
0274:  BCF    FF2.7
0276:  MOVFF  FEF,7F
027A:  RCALL  00EA
027C:  BTFSC  19.7
027E:  BSF    FF2.7
0280:  MOVFF  73,FEA
0284:  MOVFF  72,FE9
0288:  INCF   FE9,F
028A:  BTFSC  FD8.2
028C:  INCF   FEA,F
028E:  BRA    0262
0290:  RETURN 0
*
08E8:  ADDWF  FE8,W
08EA:  CLRF   FF7
08EC:  RLCF   FF7,F
08EE:  ADDLW  03
08F0:  MOVWF  FF6
08F2:  MOVLW  09
08F4:  ADDWFC FF7,F
08F6:  TBLRD*-
08F8:  MOVF   FF5,W
08FA:  MOVWF  FFA
08FC:  TBLRD*
08FE:  MOVF   FF5,W
0900:  MOVWF  FF9
0902:  DATA 3C,04
0904:  DATA 6A,04
0906:  DATA 98,04
0908:  DATA C6,04
090A:  DATA F4,04
090C:  DATA 22,05
090E:  DATA 50,05
0910:  DATA 7E,05
0912:  DATA AC,05
0914:  DATA DA,05
0916:  DATA 08,06
0918:  DATA 36,06
091A:  DATA 64,06
091C:  DATA 92,06
091E:  DATA C0,06
0920:  DATA EE,06
0922:  DATA 1C,07
0924:  DATA 4A,07
0926:  DATA 78,07
0928:  DATA A6,07
092A:  DATA D4,07
092C:  DATA 02,08
092E:  DATA 30,08
0930:  DATA 5E,08
0932:  DATA 8C,08
0934:  DATA BA,08
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
09D6:  MOVFF  73,77
09DA:  MOVFF  72,76
09DE:  MOVFF  77,03
09E2:  MOVFF  76,FE9
09E6:  MOVFF  77,FEA
09EA:  MOVF   FEF,F
09EC:  BZ    09F6
09EE:  INCF   76,F
09F0:  BTFSC  FD8.2
09F2:  INCF   77,F
09F4:  BRA    09DE
....................    while(*s2 != '\0') 
09F6:  MOVFF  75,03
09FA:  MOVFF  74,FE9
09FE:  MOVFF  75,FEA
0A02:  MOVF   FEF,F
0A04:  BZ    0A2C
....................    { 
....................       *s = *s2; 
0A06:  MOVFF  74,FE9
0A0A:  MOVFF  75,FEA
0A0E:  MOVFF  FEF,7A
0A12:  MOVFF  77,FEA
0A16:  MOVFF  76,FE9
0A1A:  MOVFF  7A,FEF
....................       ++s; 
0A1E:  INCF   76,F
0A20:  BTFSC  FD8.2
0A22:  INCF   77,F
....................       ++s2; 
0A24:  INCF   74,F
0A26:  BTFSC  FD8.2
0A28:  INCF   75,F
0A2A:  BRA    09F6
....................    } 
....................  
....................    *s = '\0'; 
0A2C:  MOVFF  76,FE9
0A30:  MOVFF  77,FEA
0A34:  CLRF   FEF
....................    return(s1); 
0A36:  MOVFF  72,01
0A3A:  MOVFF  73,02
0A3E:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <protocol.h> 
.................... #ifndef PROTOCOL_H 
.................... #define PROTOCOL_H 
....................  
....................  
.................... #define NUL				0x00 //to initialise the received variable 
.................... #define CMD_BREAK		'b' // abort recog or ping 
.................... #define CMD_SLEEP       's' // go to power down 
.................... #define CMD_KNOB        'k' // set si knob <1> 
.................... #define CMD_MIC_DIST    'k' // set microphone (<1>=-1) distance <2> 
.................... #define CMD_LEVEL       'v' // set sd level <1> 
.................... #define CMD_VERIFY_RP   'v' // verify filesystem (<1>=-1) with flags <2> (0=check only, 1=fix) 
.................... #define CMD_LANGUAGE    'l' // set si language <1> 
.................... #define CMD_LIPSYNC     'l' // start real-time lipsync (<1>=-1) with threshold <2-3>, timeout <4-5> 
.................... #define CMD_TIMEOUT     'o' // set timeout <1> 
.................... #define CMD_RECOG_SI    'i' // do si recog from ws <1> 
.................... #define CMD_TRAIN_SD    't' // train sd command at group <1> pos <2> 
.................... #define CMD_TRAILING    't' // set trailing (<1>=-1) silence <2> (0-31 = 100-875 milliseconds) 
.................... #define CMD_GROUP_SD    'g' // insert new command at group <1> pos <2> 
.................... #define CMD_UNGROUP_SD  'u' // remove command at group <1> pos <2> 
.................... #define CMD_RECOG_SD    'd' // do sd recog at group <1> (0 = trigger mixed si/sd) 
.................... #define CMD_DUMP_RP     'd' // dump message (<1>=-1) at pos <2> 
.................... #define CMD_ERASE_SD    'e' // reset command at group <1> pos <2> 
.................... #define CMD_ERASE_RP    'e' // erase recording (<1>=-1) at pos <2> 
.................... #define CMD_NAME_SD     'n' // label command at group <1> pos <2> with length <3> name <4-n> 
.................... #define CMD_COUNT_SD    'c' // get command count for group <1> 
.................... #define CMD_DUMP_SD     'p' // read command data at group <1> pos <2> 
.................... #define CMD_PLAY_RP     'p' // play recording (<1>=-1) at pos <2> with flags <3> 
.................... #define CMD_MASK_SD     'm' // get active group mask 
.................... #define CMD_RESETALL    'r' // reset all memory (commands/groups and messages), with <1>='R' 
.................... #define CMD_RESET_SD    'r' // reset only commands/groups, with <1>='D' 
.................... #define CMD_RESET_RP    'r' // reset only messages, with <1>='M' 
.................... #define CMD_RECORD_RP   'r' // record message (<1>=-1) at pos <2> with bits <3> and timeout <4> 
.................... #define CMD_ID          'x' // get version id 
.................... #define CMD_DELAY       'y' // set transmit delay <1> (log scale) 
.................... #define CMD_BAUDRATE    'a' // set baudrate <1> (bit time, 1=>115200) 
.................... #define CMD_QUERY_IO    'q' // configure, read or write I/O pin <1> of type <2> 
.................... #define CMD_PLAY_SX     'w' // wave table entry <1-2> (10-bit) playback at volume <3> 
.................... #define CMD_PLAY_DTMF   'w' // play (<1>=-1) dial tone <2> for duration <3> 
.................... #define CMD_DUMP_SX     'h' // dump wave table entries 
.................... #define CMD_DUMP_SI     'z' // dump si settings for ws <1> (or total ws count if -1) 
.................... #define CMD_SEND_SN     'j' // send sonicnet token with bits <1> index <2-3> at time <4-5> 
.................... #define CMD_RECV_SN     'f' // receive sonicnet token with bits <1> rejection <2> timeout <3-4> 
.................... #define CMD_FAST_SD     'f' // set sd/sv (<1>=-1) to use fast recognition <2> (0=normal/default, 1=fast) 
....................  
.................... #define CMD_SERVICE     '~' // send service request 
.................... #define SVC_EXPORT_SD   'X' // request export of command <2> in group <1> as raw dump 
.................... #define SVC_IMPORT_SD   'I' // request import of command <2> in group <1> as raw dump 
.................... #define SVC_VERIFY_SD   'V' // verify training of imported raw command <2> in group <1> 
....................  
.................... #define STS_SERVICE     '~' // get service reply 
.................... #define SVC_DUMP_SD     'D' // provide raw command data <1-512> followed by checksum <513-516> 
....................  
.................... #define STS_MASK        'k' // mask of active groups <1-8> 
.................... #define STS_COUNT       'c' // count of commands <1> (or number of ws <1>) 
.................... #define STS_AWAKEN      'w' // back from power down mode 
.................... #define STS_DATA        'd' // provide training <1>, conflict <2>, command label <3-35> (counted string) 
.................... #define STS_ERROR       'e' // signal error code <1-2> 
.................... #define STS_INVALID     'v' // invalid command or argument 
.................... #define STS_TIMEOUT     't' // timeout expired 
.................... #define STS_LIPSYNC     'l' // lipsync stream follows 
.................... #define STS_INTERR      'i' // back from aborted recognition (see 'break') 
.................... #define STS_SUCCESS     'o' // no errors status 
.................... #define STS_RESULT      'r' // recognised sd command <1> - training similar to sd <1> 
.................... #define STS_SIMILAR     's' // recognised si <1> (in mixed si/sd) - training similar to si <1> 
.................... #define STS_OUT_OF_MEM  'm' // no more available commands (see 'group') 
.................... #define STS_ID          'x' // provide version id <1> 
.................... #define STS_PIN         'p' // return pin state <1> 
.................... #define STS_TABLE_SX    'h' // table entries count <1-2> (10-bit), table name <3-35> (counted string) 
.................... #define STS_GRAMMAR     'z' // si grammar: flags <1>, word count <2>, labels... <3-35> (n counted strings) 
.................... #define STS_TOKEN       'f' // received sonicnet token <1-2> 
.................... #define STS_MESSAGE     'g' // message status <1> (0=empty, 4/8=bits format), length <2-7> 
....................  
.................... // protocol arguments are in the range 0x40 (-1) to 0x60 (+31) inclusive 
.................... #define CR					0x0D	//a carriage return for GSM module 
.................... #define LF					0x0A	//a new line or line feed for GSM module 
.................... #define ctrlz				0x1A	//a control+Z character for GSM module 
.................... #define ARG_MIN				0x40	//argument value (-1)	// ASCII (@) 
.................... #define ARG_ZERO			0x41	//argument value (0)	// ASCII (A) 
.................... #define ARG_ONE				0x42	//argument value (1)	// ASCII (B) 
.................... #define ARG_TWO				0x43	//argument value (2)	// ASCII (C) 
.................... #define ARG_THREE			0x44	//argument value (3)	// ASCII (D) 
.................... #define ARG_FOUR			0x45	//argument value (4)	// ASCII (E) 
.................... #define ARG_FIVE			0x46	//argument value (5)	// ASCII (F) 
.................... #define ARG_SIX				0x47	//argument value (6)	// ASCII (G) 
.................... #define ARG_SEVEN			0x48	//argument value (7)	// ASCII (H) 
.................... #define ARG_EIGHT			0x49	//argument value (8)	// ASCII (I) 
.................... #define ARG_NINE			0x4A	//argument value (9)	// ASCII (J) 
.................... #define ARG_TEN				0x4B	//argument value (10)	// ASCII (K) 
.................... #define ARG_ELEVEN			0x4C	//argument value (11)	// ASCII (L) 
.................... #define ARG_TWELVE			0x4D	//argument value (12)	// ASCII (M) 
.................... #define ARG_THIRTEEN		0x4E	//argument value (13)	// ASCII (N) 
.................... #define ARG_FOURTEEN		0x4F	//argument value (14)	// ASCII (O) 
.................... #define ARG_FIFTEEN			0x50	//argument value (15)	// ASCII (P) 
.................... #define ARG_SIXTEEN			0x51	//argument value (16)	// ASCII (Q) 
.................... #define ARG_SEVENTEEN		0x52	//argument value (17)	// ASCII (R) 
.................... #define ARG_EIGHTEEN		0x53	//argument value (18)	// ASCII (S) 
.................... #define ARG_NINETEEN		0x54	//argument value (19)	// ASCII (T) 
.................... #define ARG_TWENTY			0x55	//argument value (20)	// ASCII (U) 
.................... #define ARG_TWENTYONE		0x56	//argument value (21)	// ASCII (V) 
.................... #define ARG_TWENTYTWO		0x57	//argument value (22)	// ASCII (W) 
.................... #define ARG_TWENTYTHREE		0x58	//argument value (23)	// ASCII (X) 
.................... #define ARG_TWENTYFOUR		0x59	//argument value (24)	// ASCII (Y) 
.................... #define ARG_TWENTYFIVE		0x5A	//argument value (25)	// ASCII (Z) 
.................... #define ARG_TWENTYSIX		0x5B	//argument value (26)	// ASCII (^) 
.................... #define ARG_TWENTYSEVEN		0x5C	//argument value (27)	// ASCII ([) 
.................... #define ARG_TWENTYEIGHT		0x5D	//argument value (28)	// ASCII (\) 
.................... #define ARG_TWENTYNINE		0x5E	//argument value (29)	// ASCII (]) 
.................... #define ARG_THIRTY			0x5F	//argument value (30)	// ASCII (_) 
.................... #define ARG_MAX				0x60	//argument value (31)	// ASCII (`) 
.................... #define ARG_ACK				0x20	// to read more status arguments 
....................  
.................... #endif //PROTOCOL_H 
....................  
.................... #fuses HS,NOLVP,NOWDT,PUT,NOPROTECT 
.................... #use delay(clock=10000000) 
*
02E6:  CLRF   FEA
02E8:  MOVLW  74
02EA:  MOVWF  FE9
02EC:  MOVF   FEF,W
02EE:  BZ    030C
02F0:  MOVLW  03
02F2:  MOVWF  01
02F4:  CLRF   00
02F6:  DECFSZ 00,F
02F8:  BRA    02F6
02FA:  DECFSZ 01,F
02FC:  BRA    02F4
02FE:  MOVLW  3C
0300:  MOVWF  00
0302:  DECFSZ 00,F
0304:  BRA    0302
0306:  BRA    0308
0308:  DECFSZ FEF,F
030A:  BRA    02F0
030C:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=EVR,bits=8)		//HW serial pins EasyVR	||	EVR 
*
02DE:  BTFSS  F9E.4
02E0:  BRA    02DE
02E2:  MOVWF  FAD
02E4:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C4,rcv=PIN_B0,stream=GSM,bits=8,SAMPLE_EARLY)		//SW serial pins Fona	||	GSM 
*
00EA:  BCF    F94.4
00EC:  BCF    F8B.4
00EE:  MOVLW  08
00F0:  MOVWF  01
00F2:  BRA    00F4
00F4:  NOP   
00F6:  BSF    01.7
00F8:  BRA    0116
00FA:  BCF    01.7
00FC:  RRCF   7F,F
00FE:  BTFSC  FD8.0
0100:  BSF    F8B.4
0102:  BTFSS  FD8.0
0104:  BCF    F8B.4
0106:  BSF    01.6
0108:  BRA    0116
010A:  BCF    01.6
010C:  DECFSZ 01,F
010E:  BRA    00FC
0110:  BRA    0112
0112:  NOP   
0114:  BSF    F8B.4
0116:  MOVLW  50
0118:  MOVWF  FE9
011A:  DECFSZ FE9,F
011C:  BRA    011A
011E:  BRA    0120
0120:  BTFSC  01.7
0122:  BRA    00FA
0124:  BTFSC  01.6
0126:  BRA    010A
0128:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_A4,rcv=PIN_A3,stream=PC,bits=8)		//SW serial pins Debug	||	DB 
*
0316:  BCF    F92.4
0318:  BCF    F89.4
031A:  MOVLW  08
031C:  MOVWF  01
031E:  BRA    0320
0320:  NOP   
0322:  BSF    01.7
0324:  BRA    0342
0326:  BCF    01.7
0328:  RRCF   75,F
032A:  BTFSC  FD8.0
032C:  BSF    F89.4
032E:  BTFSS  FD8.0
0330:  BCF    F89.4
0332:  BSF    01.6
0334:  BRA    0342
0336:  BCF    01.6
0338:  DECFSZ 01,F
033A:  BRA    0328
033C:  BRA    033E
033E:  NOP   
0340:  BSF    F89.4
0342:  MOVLW  50
0344:  MOVWF  FE9
0346:  DECFSZ FE9,F
0348:  BRA    0346
034A:  BRA    034C
034C:  BTFSC  01.7
034E:  BRA    0326
0350:  BTFSC  01.6
0352:  BRA    0336
0354:  GOTO   035E (RETURN)
.................... #include <input.c> //this file must be ONLY included after #use rs232 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             input.c                               //// 
.................... ////                                                                   //// 
.................... //// Routines for reading user input over an RS232 stream.  User input //// 
.................... //// is in ASCII form and converted to requested binary or float       //// 
.................... //// format.                                                           //// 
.................... ////                                                                   //// 
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  //// 
.................... //// that serial stream.  If not, uses the last #use rs232().          //// 
.................... ////                                                                   //// 
.................... //// Some of these routines are not available unless you #include      //// 
.................... //// string.h and stdlib.h                                             //// 
.................... ////                                                                   //// 
.................... ////  int8 gethex() - read 2 char hex value from serial                //// 
.................... ////                                                                   //// 
.................... ////  get_string(s, max) - read max chars from serial and save to s    //// 
.................... ////                                                                   //// 
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   //// 
.................... ////     displays current string in s, allowing you to edit it.        //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8() -                                              //// 
.................... ////  int16 = get_Int16() -                                            //// 
.................... ////  int32 = get_Int32() -                                            //// 
.................... ////  float = get_float() -                                            //// 
.................... ////     Read value from serial.                                       //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8Edit(old) -                                       //// 
.................... ////  int16 = get_Int16Edit(old) -                                     //// 
.................... ////  int32 = get_Int32Edit(old) -                                     //// 
.................... ////  float = get_floatEdit(old) -                                     //// 
.................... ////     Similar to get_Int*() routines documented above, but first    //// 
.................... ////     it displays old value allowing you to edit it.                //// 
.................... ////                                                                   //// 
.................... ////  int = get_int() -                                                //// 
.................... ////  long = get_long() -                                              //// 
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   //// 
.................... ////     'long' datatypes.  The size of these datatypes depends on     //// 
.................... ////     the PIC architecture and compiler configuration.              //// 
.................... ////                                                                   //// 
.................... ////  int = get_intEdit(old) -                                         //// 
.................... ////  long = get_longEdit(old) -                                       //// 
.................... ////     Similar to get_int() and get_long() documented above,         //// 
.................... ////     but first it displays old value allowing you to edit it.      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __INPUT_C__ 
.................... #define __INPUT_C__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(STREAM_SERIAL_INPUT) 
....................    #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT) 
....................    #define InputPutc(c)    fputc(c, STREAM_SERIAL_INPUT) 
....................    #define InputGetc()     fgetc(STREAM_SERIAL_INPUT) 
.................... #else 
....................    #define InputKbhit()    kbhit() 
....................    #define InputPutc(c)    putc(c) 
....................    #define InputGetc()     getc() 
.................... #endif 
....................  
.................... unsigned int8 gethex1() { 
....................    char digit; 
....................  
....................    digit = InputGetc(); 
....................  
....................    InputPutc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... unsigned int8 gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    max-=2; 
....................    len=0; 
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... #ifdef _STRING 
.................... void get_stringEdit(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    len = strlen(s); 
....................  
....................    if (len) 
....................    { 
....................      #if defined(STREAM_SERIAL_INPUT) 
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s); 
....................      #else 
....................       printf("%s", s); 
....................      #endif 
....................    } 
....................  
....................    max-=2; 
....................  
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
.................... #endif 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... signed int8 get_Int8(void) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int8 get_Int8Edit(signed int8 old) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   sprintf(s, "%d", old); 
....................   get_stringEdit(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... signed int16 get_Int16(void) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int16 get_Int16Edit(signed int16 old) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... signed int32 get_Int32(void) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int32 get_Int32Edit(signed int32 old) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... float get_floatEdit(float old) { 
....................   char s[20]; 
....................   float f; 
....................  
....................   sprintf(s, "%f", old); 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #define get_int()       get_Int16() 
....................    #define get_intEdit()   get_Int16Edit() 
....................    #define get_long()      get_Int32() 
....................    #define get_longEdit()  get_Int32Edit() 
.................... #else 
....................    #define get_int()       get_Int8() 
....................    #define get_intEdit()   get_Int8Edit() 
....................    #define get_long()      get_Int16() 
....................    #define get_longEdit()  get_Int16Edit() 
.................... #endif 
....................  
.................... #endif   //_STDLIB 
....................  
.................... #endif   //__INPUT_C__ 
....................  
....................  
....................  
....................  
.................... //                       =================                       // 
.................... //=======================C O N S T A N T S=======================// 
.................... //                       =================                       // 
.................... //********Variable Def**********// 
....................  	char AT[] = "AT\r\n";// To initialize mode 
.................... 	char save[] = "AT&W\r\n"; 
.................... 	char noecho[] = "ATE0\r\n"; 
.................... 	char mode_text[] = "AT+CMGF=1\r\n";   // to set text mode 
.................... 	char endCall[] = "ATH\r\n"; 
.................... 	char ansCall[] = "ATA\r\n"; 
.................... 	char dial[20] = "ATD+1868"; 
.................... 	char end[2] = ";"; 
....................  
.................... //******Custom Sound Table******// 
.................... enum soundtable{				//constants for playback 
.................... 	BEEP, 
.................... 	SND_zero, SND_one, SND_two, SND_three, SND_four, SND_five, SND_six, SND_seven, SND_eight, SND_nine,  
.................... 	SND_please_say_a_command, 
.................... 	SND_hello_please_say_a_command, 
.................... 	SND_who_would_you_like_to_call, 
.................... 	SND_calling, 
.................... 	SND_doctor, 
.................... 	SND_say_send_to_place_the_call, 
.................... 	SND_say_reject_to_reject_the_call, 
.................... 	SND_say_answer_to_answer_the_call, 
.................... 	SND_say_end_to_cancel, 
.................... 	SND_turning_on_LED, 
.................... 	SND_turning_on_light_bulb, 
.................... 	SND_turning_off_led, 
.................... 	SND_turning_off_light_bulb, 
.................... 	SND_you_have_an_incoming_call, 
.................... 	SND_command_accepted, 
.................... 	 
.................... }; 
.................... /*enum trigger0{				//constants for trigger 
.................... 	Robot, 
.................... };*/ 
.................... enum wordSet1{					//constants for wordset1 
.................... 	WS1_ACTION, WS1_MOVE, WS1_TURN, WS1_RUN, WS1_LOOK, WS1_ATTACK, WS1_STOP, WS1_HELLO, 
.................... }; 
.................... /*enum wordset2{				//constants for wordset2 
.................... 	WS2_LEFT, WS2_RIGHT, WS2_UP, WS2_DOWN, WS2_FORWARD, WS2_BACKWARD, 
.................... }; 
.................... enum wordset3{					//constants for wordset3 
.................... 	WS3_ZERO, WS3_ONE, WS3_TWO, WS3_THREE, WS3_FOUR, WS3_FIVE, WS3_SIX, WS3_SEVEN, WS3_EIGHT, WS3_NINE, WS3_TEN, 
.................... }; 
.................... enum grammar4{					//constants for grammar4 
.................... 	GR4_OK_EASYVEEAR 
.................... }; 
.................... enum grammar5{					//constants for grammar5 
.................... 	GR5_NEXT, GR5_PREVIOUS, GR5_STOP, GR5_PLAY, GR5_PAUSE, GR5_RECORD, 
.................... }; 
.................... enum grammar6{					//constants for grammar6 
.................... 	GR6_TURN_ON, GR6_SWITCH_OFF, GR6_INCREASE, GR6_DECREASE, GR6_OPEN, GR6_CLOSE, GR6_START, GR6_STOP, 
.................... }; 
.................... enum grammar7{					//constants for grammar7 
.................... 	GR7_DOOR, GR7_T_V, GR7_TEMPERATURE, GR7_WINDOW, GR7_MUSIC, GR7_LIGHT, GR7_TIMER, GR7_OVEN, GR7_WASHING_MACHINE, GR7_DISH_WASHER, 
.................... }; 
.................... enum grammar8{					//constants for grammar8 
.................... 	GR8_YES, GR8_NO, 
.................... }; 
.................... enum grammar9{					//constants for grammar9 
.................... 	GR9_HELLO_DEVICE, 
.................... }; 
.................... enum grammar10{					//constants for grammar10 
.................... 	GR10_PASSWORD_SETUP, GR10_PASSWORD_ACTIVATED, GR10_CURTAIN_UP, GR10_CURTAIN_DOWN, GR10_LIGHTS_ON, GR10_LIGHTS_OFF, 
.................... }; 
....................  */ 
.................... enum group1{					//constants for action words 
.................... 	G1_CALL, G1_ANSWER, G1_LIGHTS, G1_LED, G1_OTHER, G1_END 
.................... }; 
.................... enum group2{					//constants for target of action words 
.................... 	G2_DOCTOR, G2_PARENT, G2_MOM, G2_DAD, G2_SON, G2_DAUGHTER, G2_ON, G2_OFF, G2_OTHER, 
.................... }; 
.................... enum group3{ 
.................... 	G3_ZERO, G3_ONE, G3_TWO, G3_THREE, G3_FOUR, G3_FIVE, G3_SIX, G3_SEVEN, G3_EIGHT, G3_NINE, G3_TEN 
.................... }; 
....................  
....................  
....................  
.................... //                   ========================                    // 
.................... //===================S T A T E  M A C H I N E====================// 
.................... //                   ========================                    // 
.................... //						    DEFINITIONS				    		 // 
.................... enum states {	//State definitions 
.................... 	STATE1, STATE2, STATE3, S_GP2, S_NUMBERS, 
.................... }; 
.................... enum events {	//Event definitions  
.................... 	E_LIS_WS1, E_LIS_GP1, E_LIS_GP2, E_LIS_NUMS, E_CALL_SENT, E_INCOMING_CALL, E_ANS_CALL, E_END_CALL, E_TASK_FINISHED, E_END, 
.................... }; 
.................... //a golbal variable for sending messages to another state 
.................... //particularly messages from GP1 to GP2 
.................... volatile int messages; 
.................... const char error = NUL; 
....................  
....................  
....................  
.................... //                   ========================                    // 
.................... //===================F U N C T I O N  D E F N====================// 
.................... //                   ========================                    // 
.................... //**********System Fns**********// 
.................... /* might not need these blinking functions 
.................... void blinkA0(int _a){			//LED indicator 
.................... 	int _i = 0; 
.................... 	for (_i; _i < _a; _i++ ){ 
.................... 		output_high(PIN_A0); 
.................... 		delay_ms(50); 
.................... 		output_low(PIN_A0); 
.................... 		delay_ms(100); 
.................... 	} 
.................... } */ 
.................... void blinkD0(int _a){			//LED indicator 
*
0960:  CLRF   73
.................... 	int _i = 0;	 
.................... 	for (_i; _i < _a; _i++ ){ 
0962:  MOVF   72,W
0964:  SUBWF  73,W
0966:  BC    0980
.................... 		output_high(PIN_D0); 
0968:  BCF    F95.0
096A:  BSF    F8C.0
.................... 		delay_ms(50); 
096C:  MOVLW  32
096E:  MOVWF  74
0970:  RCALL  02E6
.................... 		output_low(PIN_D0); 
0972:  BCF    F95.0
0974:  BCF    F8C.0
.................... 		delay_ms(100); 
0976:  MOVLW  64
0978:  MOVWF  74
097A:  RCALL  02E6
097C:  INCF   73,F
097E:  BRA    0962
.................... 	} 
0980:  RETURN 0
.................... }  
.................... void blinkD2(int _a){			//LED indicator 
*
040A:  CLRF   73
.................... 	int _i = 0;	 
.................... 	for (_i; _i < _a; _i++ ){ 
040C:  MOVF   72,W
040E:  SUBWF  73,W
0410:  BC    042A
.................... 		output_high(PIN_D2); 
0412:  BCF    F95.2
0414:  BSF    F8C.2
.................... 		delay_ms(100); 
0416:  MOVLW  64
0418:  MOVWF  74
041A:  RCALL  02E6
.................... 		output_low(PIN_D2); 
041C:  BCF    F95.2
041E:  BCF    F8C.2
.................... 		delay_ms(200); 
0420:  MOVLW  C8
0422:  MOVWF  74
0424:  RCALL  02E6
0426:  INCF   73,F
0428:  BRA    040C
.................... 	} 
042A:  RETURN 0
.................... }  
.................... void ms25(){ 
.................... 	delay_ms(30);}		//easy way to call ms25(25) 
*
030E:  MOVLW  1E
0310:  MOVWF  74
0312:  RCALL  02E6
0314:  RETURN 0
.................... void print_debug(char dbg){ 
.................... 	fputc(dbg,PC); 
*
0358:  MOVFF  74,75
035C:  BRA    0316
035E:  RETURN 0
.................... } 
.................... 	 
.................... //***********Fona Fns***********// 
.................... void reset_gsm(){ 
.................... 	output_low(PIN_C5); 
.................... 	delay_ms(100); 
.................... 	output_high(PIN_C5); 
.................... 	delay_ms(10000);	//delays the code so that the GSM module would be able to reconnect to the network 
.................... } 
.................... /* boolean gsmReplyOK(char _reply_gsm[]){	//checks to see if the reply is ring...might not actually be needed 
.................... 	if(strncmp(_reply_gsm,OK,strlen(OK))==0){ 
.................... 		return true; 
.................... 	}else{ 
.................... 		return false; 
.................... 	} 
.................... } */ 
.................... void gsmSetup(){ 
.................... //NOTE: we do not necessarily need to check to see if the data received is "OK". we can assume that it will happen 
.................... 	fprintf(GSM,AT); 
*
0292:  CLRF   FEA
0294:  MOVLW  22
0296:  MOVWF  FE9
0298:  RCALL  0262
.................... 	delay_us(50); 
029A:  MOVLW  29
029C:  MOVWF  00
029E:  DECFSZ 00,F
02A0:  BRA    029E
02A2:  NOP   
.................... 	fprintf(GSM,noecho); 
02A4:  CLRF   FEA
02A6:  MOVLW  2E
02A8:  MOVWF  FE9
02AA:  RCALL  0262
.................... 	delay_us(50); 
02AC:  MOVLW  29
02AE:  MOVWF  00
02B0:  DECFSZ 00,F
02B2:  BRA    02B0
02B4:  NOP   
.................... 	fprintf(GSM,mode_text); 
02B6:  CLRF   FEA
02B8:  MOVLW  35
02BA:  MOVWF  FE9
02BC:  RCALL  0262
.................... 	delay_us(50); 
02BE:  MOVLW  29
02C0:  MOVWF  00
02C2:  DECFSZ 00,F
02C4:  BRA    02C2
02C6:  NOP   
.................... 	fprintf(GSM,save); 
02C8:  CLRF   FEA
02CA:  MOVLW  27
02CC:  MOVWF  FE9
02CE:  RCALL  0262
.................... 	delay_us(50); 
02D0:  MOVLW  29
02D2:  MOVWF  00
02D4:  DECFSZ 00,F
02D6:  BRA    02D4
02D8:  NOP   
02DA:  GOTO   0B26 (RETURN)
.................... 	 
.................... } 
.................... /* void gsmAction(char _a){ 
.................... 	switch (_a){ 
.................... 		case 'a': 
.................... 			fprintf(GSM,ansCall); 
.................... 			break; 
.................... 		case 'c': 
.................... 			fprintf(GSM,"ATD+18686822015;\r\n"); 
.................... 			break; 
.................... 		case 'e': 
.................... 			fprintf(GSM,endCall); 
.................... 			break; 
.................... 		default: _a = NUL; 
.................... 		break; 
.................... 	} 
.................... } */ 
.................... //***********EVR Fns***********// 
.................... void playback(int _playback){//plays back custom sound 
*
042C:  CLRF   73
.................... 	char _rec_play = NUL; 
.................... 	switch (_playback){ 
042E:  MOVF   72,W
0430:  ADDLW  E6
0432:  BTFSC  FD8.0
0434:  BRA    08E6
0436:  ADDLW  1A
0438:  GOTO   08E8
.................... 		case BEEP: 
.................... 			while (_rec_play != STS_SUCCESS){ 
043C:  MOVF   73,W
043E:  SUBLW  6F
0440:  BZ    0468
.................... 				fputc(CMD_PLAY_SX,EVR); 
0442:  MOVLW  77
0444:  RCALL  02DE
.................... 				ms25(); 
0446:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0448:  MOVLW  41
044A:  RCALL  02DE
.................... 				ms25(); 
044C:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
044E:  MOVLW  41
0450:  RCALL  02DE
.................... 				ms25(); 
0452:  RCALL  030E
.................... 				fputc(ARG_FIFTEEN,EVR); 
0454:  MOVLW  50
0456:  RCALL  02DE
.................... 				ms25();  
0458:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
045A:  BTFSS  F9E.5
045C:  BRA    0466
045E:  BTFSS  F9E.5
0460:  BRA    045E
0462:  MOVFF  FAE,73
0466:  BRA    043C
.................... 			} 
.................... 			break; 
0468:  BRA    08E6
.................... 		case SND_zero: 
.................... 			while (_rec_play != STS_SUCCESS){ 
046A:  MOVF   73,W
046C:  SUBLW  6F
046E:  BZ    0496
.................... 				fputc(CMD_PLAY_SX,EVR); 
0470:  MOVLW  77
0472:  RCALL  02DE
.................... 				ms25(); 
0474:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0476:  MOVLW  41
0478:  RCALL  02DE
.................... 				ms25(); 
047A:  RCALL  030E
.................... 				fputc(ARG_ONE,EVR); 
047C:  MOVLW  42
047E:  RCALL  02DE
.................... 				ms25(); 
0480:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0482:  MOVLW  48
0484:  RCALL  02DE
.................... 				ms25(); 
0486:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0488:  BTFSS  F9E.5
048A:  BRA    0494
048C:  BTFSS  F9E.5
048E:  BRA    048C
0490:  MOVFF  FAE,73
0494:  BRA    046A
.................... 			} 
.................... 			break; 
0496:  BRA    08E6
.................... 		case SND_one: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0498:  MOVF   73,W
049A:  SUBLW  6F
049C:  BZ    04C4
.................... 				fputc(CMD_PLAY_SX,EVR); 
049E:  MOVLW  77
04A0:  RCALL  02DE
.................... 				ms25(); 
04A2:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
04A4:  MOVLW  41
04A6:  RCALL  02DE
.................... 				ms25(); 
04A8:  RCALL  030E
.................... 				fputc(ARG_TWO,EVR); 
04AA:  MOVLW  43
04AC:  RCALL  02DE
.................... 				ms25(); 
04AE:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
04B0:  MOVLW  48
04B2:  RCALL  02DE
.................... 				ms25(); 
04B4:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
04B6:  BTFSS  F9E.5
04B8:  BRA    04C2
04BA:  BTFSS  F9E.5
04BC:  BRA    04BA
04BE:  MOVFF  FAE,73
04C2:  BRA    0498
.................... 			} 
.................... 			break; 
04C4:  BRA    08E6
.................... 		case SND_two: 
.................... 			while (_rec_play != STS_SUCCESS){ 
04C6:  MOVF   73,W
04C8:  SUBLW  6F
04CA:  BZ    04F2
.................... 				fputc(CMD_PLAY_SX,EVR); 
04CC:  MOVLW  77
04CE:  RCALL  02DE
.................... 				ms25(); 
04D0:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
04D2:  MOVLW  41
04D4:  RCALL  02DE
.................... 				ms25(); 
04D6:  RCALL  030E
.................... 				fputc(ARG_THREE,EVR); 
04D8:  MOVLW  44
04DA:  RCALL  02DE
.................... 				ms25(); 
04DC:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
04DE:  MOVLW  48
04E0:  RCALL  02DE
.................... 				ms25(); 
04E2:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
04E4:  BTFSS  F9E.5
04E6:  BRA    04F0
04E8:  BTFSS  F9E.5
04EA:  BRA    04E8
04EC:  MOVFF  FAE,73
04F0:  BRA    04C6
.................... 			} 
.................... 			break; 
04F2:  BRA    08E6
.................... 		case SND_three: 
.................... 			while (_rec_play != STS_SUCCESS){ 
04F4:  MOVF   73,W
04F6:  SUBLW  6F
04F8:  BZ    0520
.................... 				fputc(CMD_PLAY_SX,EVR); 
04FA:  MOVLW  77
04FC:  RCALL  02DE
.................... 				ms25(); 
04FE:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0500:  MOVLW  41
0502:  RCALL  02DE
.................... 				ms25(); 
0504:  RCALL  030E
.................... 				fputc(ARG_FOUR,EVR); 
0506:  MOVLW  45
0508:  RCALL  02DE
.................... 				ms25(); 
050A:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
050C:  MOVLW  48
050E:  RCALL  02DE
.................... 				ms25(); 
0510:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0512:  BTFSS  F9E.5
0514:  BRA    051E
0516:  BTFSS  F9E.5
0518:  BRA    0516
051A:  MOVFF  FAE,73
051E:  BRA    04F4
.................... 			} 
.................... 			break; 
0520:  BRA    08E6
.................... 		case SND_four: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0522:  MOVF   73,W
0524:  SUBLW  6F
0526:  BZ    054E
.................... 				fputc(CMD_PLAY_SX,EVR); 
0528:  MOVLW  77
052A:  RCALL  02DE
.................... 				ms25(); 
052C:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
052E:  MOVLW  41
0530:  RCALL  02DE
.................... 				ms25(); 
0532:  RCALL  030E
.................... 				fputc(ARG_FIVE,EVR); 
0534:  MOVLW  46
0536:  RCALL  02DE
.................... 				ms25(); 
0538:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
053A:  MOVLW  48
053C:  RCALL  02DE
.................... 				ms25(); 
053E:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0540:  BTFSS  F9E.5
0542:  BRA    054C
0544:  BTFSS  F9E.5
0546:  BRA    0544
0548:  MOVFF  FAE,73
054C:  BRA    0522
.................... 			} 
.................... 			break; 
054E:  BRA    08E6
.................... 		case SND_five: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0550:  MOVF   73,W
0552:  SUBLW  6F
0554:  BZ    057C
.................... 				fputc(CMD_PLAY_SX,EVR); 
0556:  MOVLW  77
0558:  RCALL  02DE
.................... 				ms25(); 
055A:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
055C:  MOVLW  41
055E:  RCALL  02DE
.................... 				ms25(); 
0560:  RCALL  030E
.................... 				fputc(ARG_SIX,EVR); 
0562:  MOVLW  47
0564:  RCALL  02DE
.................... 				ms25(); 
0566:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0568:  MOVLW  48
056A:  RCALL  02DE
.................... 				ms25(); 
056C:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
056E:  BTFSS  F9E.5
0570:  BRA    057A
0572:  BTFSS  F9E.5
0574:  BRA    0572
0576:  MOVFF  FAE,73
057A:  BRA    0550
.................... 			} 
.................... 			break; 
057C:  BRA    08E6
.................... 		case SND_six: 
.................... 			while (_rec_play != STS_SUCCESS){ 
057E:  MOVF   73,W
0580:  SUBLW  6F
0582:  BZ    05AA
.................... 				fputc(CMD_PLAY_SX,EVR); 
0584:  MOVLW  77
0586:  RCALL  02DE
.................... 				ms25(); 
0588:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
058A:  MOVLW  41
058C:  RCALL  02DE
.................... 				ms25(); 
058E:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0590:  MOVLW  48
0592:  RCALL  02DE
.................... 				ms25(); 
0594:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0596:  MOVLW  48
0598:  RCALL  02DE
.................... 				ms25(); 
059A:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
059C:  BTFSS  F9E.5
059E:  BRA    05A8
05A0:  BTFSS  F9E.5
05A2:  BRA    05A0
05A4:  MOVFF  FAE,73
05A8:  BRA    057E
.................... 			} 
.................... 			break; 
05AA:  BRA    08E6
.................... 		case SND_seven: 
.................... 			while (_rec_play != STS_SUCCESS){ 
05AC:  MOVF   73,W
05AE:  SUBLW  6F
05B0:  BZ    05D8
.................... 				fputc(CMD_PLAY_SX,EVR); 
05B2:  MOVLW  77
05B4:  RCALL  02DE
.................... 				ms25(); 
05B6:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
05B8:  MOVLW  41
05BA:  RCALL  02DE
.................... 				ms25(); 
05BC:  RCALL  030E
.................... 				fputc(ARG_EIGHT,EVR); 
05BE:  MOVLW  49
05C0:  RCALL  02DE
.................... 				ms25(); 
05C2:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
05C4:  MOVLW  48
05C6:  RCALL  02DE
.................... 				ms25(); 
05C8:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
05CA:  BTFSS  F9E.5
05CC:  BRA    05D6
05CE:  BTFSS  F9E.5
05D0:  BRA    05CE
05D2:  MOVFF  FAE,73
05D6:  BRA    05AC
.................... 			} 
.................... 			break; 
05D8:  BRA    08E6
.................... 		case SND_eight: 
.................... 			while (_rec_play != STS_SUCCESS){ 
05DA:  MOVF   73,W
05DC:  SUBLW  6F
05DE:  BZ    0606
.................... 				fputc(CMD_PLAY_SX,EVR); 
05E0:  MOVLW  77
05E2:  RCALL  02DE
.................... 				ms25(); 
05E4:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
05E6:  MOVLW  41
05E8:  RCALL  02DE
.................... 				ms25(); 
05EA:  RCALL  030E
.................... 				fputc(ARG_NINE,EVR); 
05EC:  MOVLW  4A
05EE:  RCALL  02DE
.................... 				ms25(); 
05F0:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
05F2:  MOVLW  48
05F4:  RCALL  02DE
.................... 				ms25(); 
05F6:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
05F8:  BTFSS  F9E.5
05FA:  BRA    0604
05FC:  BTFSS  F9E.5
05FE:  BRA    05FC
0600:  MOVFF  FAE,73
0604:  BRA    05DA
.................... 			} 
.................... 			break; 
0606:  BRA    08E6
.................... 		case SND_nine: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0608:  MOVF   73,W
060A:  SUBLW  6F
060C:  BZ    0634
.................... 				fputc(CMD_PLAY_SX,EVR); 
060E:  MOVLW  77
0610:  RCALL  02DE
.................... 				ms25(); 
0612:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0614:  MOVLW  41
0616:  RCALL  02DE
.................... 				ms25(); 
0618:  RCALL  030E
.................... 				fputc(ARG_TEN,EVR); 
061A:  MOVLW  4B
061C:  RCALL  02DE
.................... 				ms25(); 
061E:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0620:  MOVLW  48
0622:  RCALL  02DE
.................... 				ms25(); 
0624:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0626:  BTFSS  F9E.5
0628:  BRA    0632
062A:  BTFSS  F9E.5
062C:  BRA    062A
062E:  MOVFF  FAE,73
0632:  BRA    0608
.................... 			} 
.................... 			break; 
0634:  BRA    08E6
.................... 		case SND_please_say_a_command: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0636:  MOVF   73,W
0638:  SUBLW  6F
063A:  BZ    0662
.................... 				fputc(CMD_PLAY_SX,EVR); 
063C:  MOVLW  77
063E:  RCALL  02DE
.................... 				ms25(); 
0640:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0642:  MOVLW  41
0644:  RCALL  02DE
.................... 				ms25(); 
0646:  RCALL  030E
.................... 				fputc(ARG_ELEVEN,EVR); 
0648:  MOVLW  4C
064A:  RCALL  02DE
.................... 				ms25(); 
064C:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
064E:  MOVLW  48
0650:  RCALL  02DE
.................... 				ms25(); 
0652:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0654:  BTFSS  F9E.5
0656:  BRA    0660
0658:  BTFSS  F9E.5
065A:  BRA    0658
065C:  MOVFF  FAE,73
0660:  BRA    0636
.................... 			} 
.................... 			break; 
0662:  BRA    08E6
.................... 		case SND_hello_please_say_a_command: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0664:  MOVF   73,W
0666:  SUBLW  6F
0668:  BZ    0690
.................... 				fputc(CMD_PLAY_SX,EVR); 
066A:  MOVLW  77
066C:  RCALL  02DE
.................... 				ms25(); 
066E:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0670:  MOVLW  41
0672:  RCALL  02DE
.................... 				ms25(); 
0674:  RCALL  030E
.................... 				fputc(ARG_TWELVE,EVR); 
0676:  MOVLW  4D
0678:  RCALL  02DE
.................... 				ms25(); 
067A:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
067C:  MOVLW  48
067E:  RCALL  02DE
.................... 				ms25(); 
0680:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0682:  BTFSS  F9E.5
0684:  BRA    068E
0686:  BTFSS  F9E.5
0688:  BRA    0686
068A:  MOVFF  FAE,73
068E:  BRA    0664
.................... 			} 
.................... 			break; 
0690:  BRA    08E6
.................... 		case SND_who_would_you_like_to_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0692:  MOVF   73,W
0694:  SUBLW  6F
0696:  BZ    06BE
.................... 				fputc(CMD_PLAY_SX,EVR); 
0698:  MOVLW  77
069A:  RCALL  02DE
.................... 				ms25(); 
069C:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
069E:  MOVLW  41
06A0:  RCALL  02DE
.................... 				ms25(); 
06A2:  RCALL  030E
.................... 				fputc(ARG_THIRTEEN,EVR); 
06A4:  MOVLW  4E
06A6:  RCALL  02DE
.................... 				ms25(); 
06A8:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
06AA:  MOVLW  48
06AC:  RCALL  02DE
.................... 				ms25(); 
06AE:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
06B0:  BTFSS  F9E.5
06B2:  BRA    06BC
06B4:  BTFSS  F9E.5
06B6:  BRA    06B4
06B8:  MOVFF  FAE,73
06BC:  BRA    0692
.................... 			} 
.................... 			break; 
06BE:  BRA    08E6
.................... 		case SND_calling: 
.................... 			while (_rec_play != STS_SUCCESS){ 
06C0:  MOVF   73,W
06C2:  SUBLW  6F
06C4:  BZ    06EC
.................... 				fputc(CMD_PLAY_SX,EVR); 
06C6:  MOVLW  77
06C8:  RCALL  02DE
.................... 				ms25(); 
06CA:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
06CC:  MOVLW  41
06CE:  RCALL  02DE
.................... 				ms25(); 
06D0:  RCALL  030E
.................... 				fputc(ARG_FOURTEEN,EVR); 
06D2:  MOVLW  4F
06D4:  RCALL  02DE
.................... 				ms25(); 
06D6:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
06D8:  MOVLW  48
06DA:  RCALL  02DE
.................... 				ms25(); 
06DC:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
06DE:  BTFSS  F9E.5
06E0:  BRA    06EA
06E2:  BTFSS  F9E.5
06E4:  BRA    06E2
06E6:  MOVFF  FAE,73
06EA:  BRA    06C0
.................... 			} 
.................... 			break; 
06EC:  BRA    08E6
.................... 		case SND_doctor: 
.................... 			while (_rec_play != STS_SUCCESS){ 
06EE:  MOVF   73,W
06F0:  SUBLW  6F
06F2:  BZ    071A
.................... 				fputc(CMD_PLAY_SX,EVR); 
06F4:  MOVLW  77
06F6:  RCALL  02DE
.................... 				ms25(); 
06F8:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
06FA:  MOVLW  41
06FC:  RCALL  02DE
.................... 				ms25(); 
06FE:  RCALL  030E
.................... 				fputc(ARG_FIFTEEN,EVR); 
0700:  MOVLW  50
0702:  RCALL  02DE
.................... 				ms25(); 
0704:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0706:  MOVLW  48
0708:  RCALL  02DE
.................... 				ms25(); 
070A:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
070C:  BTFSS  F9E.5
070E:  BRA    0718
0710:  BTFSS  F9E.5
0712:  BRA    0710
0714:  MOVFF  FAE,73
0718:  BRA    06EE
.................... 			} 
.................... 			break; 
071A:  BRA    08E6
.................... 		case SND_say_send_to_place_the_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
071C:  MOVF   73,W
071E:  SUBLW  6F
0720:  BZ    0748
.................... 				fputc(CMD_PLAY_SX,EVR); 
0722:  MOVLW  77
0724:  RCALL  02DE
.................... 				ms25(); 
0726:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0728:  MOVLW  41
072A:  RCALL  02DE
.................... 				ms25(); 
072C:  RCALL  030E
.................... 				fputc(ARG_SIXTEEN,EVR); 
072E:  MOVLW  51
0730:  RCALL  02DE
.................... 				ms25(); 
0732:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0734:  MOVLW  48
0736:  RCALL  02DE
.................... 				ms25(); 
0738:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
073A:  BTFSS  F9E.5
073C:  BRA    0746
073E:  BTFSS  F9E.5
0740:  BRA    073E
0742:  MOVFF  FAE,73
0746:  BRA    071C
.................... 			} 
.................... 			break; 
0748:  BRA    08E6
.................... 		case SND_say_reject_to_reject_the_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
074A:  MOVF   73,W
074C:  SUBLW  6F
074E:  BZ    0776
.................... 				fputc(CMD_PLAY_SX,EVR); 
0750:  MOVLW  77
0752:  RCALL  02DE
.................... 				ms25(); 
0754:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0756:  MOVLW  41
0758:  RCALL  02DE
.................... 				ms25(); 
075A:  RCALL  030E
.................... 				fputc(ARG_SEVENTEEN,EVR); 
075C:  MOVLW  52
075E:  RCALL  02DE
.................... 				ms25(); 
0760:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0762:  MOVLW  48
0764:  RCALL  02DE
.................... 				ms25(); 
0766:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0768:  BTFSS  F9E.5
076A:  BRA    0774
076C:  BTFSS  F9E.5
076E:  BRA    076C
0770:  MOVFF  FAE,73
0774:  BRA    074A
.................... 			} 
.................... 			break; 
0776:  BRA    08E6
.................... 		case SND_say_answer_to_answer_the_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0778:  MOVF   73,W
077A:  SUBLW  6F
077C:  BZ    07A4
.................... 				fputc(CMD_PLAY_SX,EVR); 
077E:  MOVLW  77
0780:  RCALL  02DE
.................... 				ms25(); 
0782:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0784:  MOVLW  41
0786:  RCALL  02DE
.................... 				ms25(); 
0788:  RCALL  030E
.................... 				fputc(ARG_EIGHTEEN,EVR); 
078A:  MOVLW  53
078C:  RCALL  02DE
.................... 				ms25(); 
078E:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0790:  MOVLW  48
0792:  RCALL  02DE
.................... 				ms25(); 
0794:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0796:  BTFSS  F9E.5
0798:  BRA    07A2
079A:  BTFSS  F9E.5
079C:  BRA    079A
079E:  MOVFF  FAE,73
07A2:  BRA    0778
.................... 			} 
.................... 			break; 
07A4:  BRA    08E6
.................... 		case SND_say_end_to_cancel: 
.................... 			while (_rec_play != STS_SUCCESS){ 
07A6:  MOVF   73,W
07A8:  SUBLW  6F
07AA:  BZ    07D2
.................... 				fputc(CMD_PLAY_SX,EVR); 
07AC:  MOVLW  77
07AE:  RCALL  02DE
.................... 				ms25(); 
07B0:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
07B2:  MOVLW  41
07B4:  RCALL  02DE
.................... 				ms25(); 
07B6:  RCALL  030E
.................... 				fputc(ARG_NINETEEN,EVR); 
07B8:  MOVLW  54
07BA:  RCALL  02DE
.................... 				ms25(); 
07BC:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
07BE:  MOVLW  48
07C0:  RCALL  02DE
.................... 				ms25(); 
07C2:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
07C4:  BTFSS  F9E.5
07C6:  BRA    07D0
07C8:  BTFSS  F9E.5
07CA:  BRA    07C8
07CC:  MOVFF  FAE,73
07D0:  BRA    07A6
.................... 			} 
.................... 			break; 
07D2:  BRA    08E6
.................... 		case SND_turning_on_LED: 
.................... 			while (_rec_play != STS_SUCCESS){ 
07D4:  MOVF   73,W
07D6:  SUBLW  6F
07D8:  BZ    0800
.................... 				fputc(CMD_PLAY_SX,EVR); 
07DA:  MOVLW  77
07DC:  RCALL  02DE
.................... 				ms25(); 
07DE:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
07E0:  MOVLW  41
07E2:  RCALL  02DE
.................... 				ms25(); 
07E4:  RCALL  030E
.................... 				fputc(ARG_TWENTY,EVR); 
07E6:  MOVLW  55
07E8:  RCALL  02DE
.................... 				ms25(); 
07EA:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
07EC:  MOVLW  48
07EE:  RCALL  02DE
.................... 				ms25(); 
07F0:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
07F2:  BTFSS  F9E.5
07F4:  BRA    07FE
07F6:  BTFSS  F9E.5
07F8:  BRA    07F6
07FA:  MOVFF  FAE,73
07FE:  BRA    07D4
.................... 			} 
.................... 			break; 
0800:  BRA    08E6
.................... 		case SND_turning_on_light_bulb: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0802:  MOVF   73,W
0804:  SUBLW  6F
0806:  BZ    082E
.................... 				fputc(CMD_PLAY_SX,EVR); 
0808:  MOVLW  77
080A:  RCALL  02DE
.................... 				ms25(); 
080C:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
080E:  MOVLW  41
0810:  RCALL  02DE
.................... 				ms25(); 
0812:  RCALL  030E
.................... 				fputc(ARG_TWENTYONE,EVR); 
0814:  MOVLW  56
0816:  RCALL  02DE
.................... 				ms25(); 
0818:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
081A:  MOVLW  48
081C:  RCALL  02DE
.................... 				ms25(); 
081E:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
0820:  BTFSS  F9E.5
0822:  BRA    082C
0824:  BTFSS  F9E.5
0826:  BRA    0824
0828:  MOVFF  FAE,73
082C:  BRA    0802
.................... 			} 
.................... 			break; 
082E:  BRA    08E6
.................... 		case SND_turning_off_led: 
.................... 			while (_rec_play != STS_SUCCESS){ 
0830:  MOVF   73,W
0832:  SUBLW  6F
0834:  BZ    085C
.................... 				fputc(CMD_PLAY_SX,EVR); 
0836:  MOVLW  77
0838:  RCALL  02DE
.................... 				ms25(); 
083A:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
083C:  MOVLW  41
083E:  RCALL  02DE
.................... 				ms25(); 
0840:  RCALL  030E
.................... 				fputc(ARG_TWENTYTWO,EVR); 
0842:  MOVLW  57
0844:  RCALL  02DE
.................... 				ms25(); 
0846:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0848:  MOVLW  48
084A:  RCALL  02DE
.................... 				ms25(); 
084C:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
084E:  BTFSS  F9E.5
0850:  BRA    085A
0852:  BTFSS  F9E.5
0854:  BRA    0852
0856:  MOVFF  FAE,73
085A:  BRA    0830
.................... 			} 
.................... 			break; 
085C:  BRA    08E6
.................... 		case SND_turning_off_light_bulb: 
.................... 			while (_rec_play != STS_SUCCESS){ 
085E:  MOVF   73,W
0860:  SUBLW  6F
0862:  BZ    088A
.................... 				fputc(CMD_PLAY_SX,EVR); 
0864:  MOVLW  77
0866:  RCALL  02DE
.................... 				ms25(); 
0868:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
086A:  MOVLW  41
086C:  RCALL  02DE
.................... 				ms25(); 
086E:  RCALL  030E
.................... 				fputc(ARG_TWENTYTHREE,EVR); 
0870:  MOVLW  58
0872:  RCALL  02DE
.................... 				ms25(); 
0874:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
0876:  MOVLW  48
0878:  RCALL  02DE
.................... 				ms25(); 
087A:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
087C:  BTFSS  F9E.5
087E:  BRA    0888
0880:  BTFSS  F9E.5
0882:  BRA    0880
0884:  MOVFF  FAE,73
0888:  BRA    085E
.................... 			} 
.................... 			break;  
088A:  BRA    08E6
.................... 		case SND_you_have_an_incoming_call: 
.................... 			while (_rec_play != STS_SUCCESS){ 
088C:  MOVF   73,W
088E:  SUBLW  6F
0890:  BZ    08B8
.................... 				fputc(CMD_PLAY_SX,EVR); 
0892:  MOVLW  77
0894:  RCALL  02DE
.................... 				ms25(); 
0896:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
0898:  MOVLW  41
089A:  RCALL  02DE
.................... 				ms25(); 
089C:  RCALL  030E
.................... 				fputc(ARG_TWENTYFOUR,EVR); 
089E:  MOVLW  59
08A0:  RCALL  02DE
.................... 				ms25(); 
08A2:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
08A4:  MOVLW  48
08A6:  RCALL  02DE
.................... 				ms25(); 
08A8:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
08AA:  BTFSS  F9E.5
08AC:  BRA    08B6
08AE:  BTFSS  F9E.5
08B0:  BRA    08AE
08B2:  MOVFF  FAE,73
08B6:  BRA    088C
.................... 			} 
.................... 			break; 
08B8:  BRA    08E6
.................... 		case SND_command_accepted: 
.................... 			while (_rec_play != STS_SUCCESS){ 
08BA:  MOVF   73,W
08BC:  SUBLW  6F
08BE:  BZ    08E6
.................... 				fputc(CMD_PLAY_SX,EVR); 
08C0:  MOVLW  77
08C2:  RCALL  02DE
.................... 				ms25(); 
08C4:  RCALL  030E
.................... 				fputc(ARG_ZERO,EVR); 
08C6:  MOVLW  41
08C8:  RCALL  02DE
.................... 				ms25(); 
08CA:  RCALL  030E
.................... 				fputc(ARG_TWENTYFIVE,EVR); 
08CC:  MOVLW  5A
08CE:  RCALL  02DE
.................... 				ms25(); 
08D0:  RCALL  030E
.................... 				fputc(ARG_SEVEN,EVR); 
08D2:  MOVLW  48
08D4:  RCALL  02DE
.................... 				ms25(); 
08D6:  RCALL  030E
.................... 				if (kbhit(EVR)) _rec_play = fgetc(EVR); 
08D8:  BTFSS  F9E.5
08DA:  BRA    08E4
08DC:  BTFSS  F9E.5
08DE:  BRA    08DC
08E0:  MOVFF  FAE,73
08E4:  BRA    08BA
.................... 			} 
.................... 			break; 
.................... 	} 
08E6:  RETURN 0
.................... } 
.................... void stop_EVR(){				//stop current action 
*
0360:  CLRF   72
.................... 	char _rec_halt = NUL; 
.................... 	while (_rec_halt != STS_SUCCESS){ 
0362:  MOVF   72,W
0364:  SUBLW  6F
0366:  BZ    0382
.................... 		fputc(CMD_BREAK,EVR); 
0368:  MOVLW  62
036A:  RCALL  02DE
.................... 		ms25(); 
036C:  RCALL  030E
.................... 		if (kbhit(EVR)) _rec_halt = fgetc(EVR); 
036E:  BTFSS  F9E.5
0370:  BRA    037A
0372:  BTFSS  F9E.5
0374:  BRA    0372
0376:  MOVFF  FAE,72
.................... 		print_debug(_rec_halt); 
037A:  MOVFF  72,74
037E:  RCALL  0358
0380:  BRA    0362
.................... 	} 
.................... 	_rec_halt = NUL; 
0382:  CLRF   72
0384:  GOTO   0B28 (RETURN)
.................... } 
.................... void go_to_sleep(){				//put device to sleep and wake on double clap or received a character 
.................... 	char _rec_sleep = NUL; 
.................... 	//this here is to put device to sleep and set it to wake on double clap 
.................... 	while (_rec_sleep != STS_SUCCESS){ 
.................... 		fputc(CMD_SLEEP,EVR); 
.................... 		print_debug(CMD_SLEEP); 
.................... 		ms25(); 
.................... 		fputc(ARG_THREE,EVR); 
.................... 		print_debug(ARG_THREE); 
.................... 		ms25(); 
.................... 		_rec_sleep = fgetc(EVR); 
.................... 		print_debug(_rec_sleep); 
.................... 	} 
.................... } 
.................... int wait(){						//waits to be waken by the user 
.................... 	// char rec_wait; 
.................... 	char back_from_power_down = NUL; 
.................... 	int event_wake = 0; 
.................... 	//this here is to wait until the user activates it by double clapping. 
.................... 	while (back_from_power_down != STS_AWAKEN){ 
.................... 		back_from_power_down = fgetc(EVR); 
.................... 		print_debug(back_from_power_down); 
.................... 	} 
.................... 	// playback(SND_one); 
.................... 	back_from_power_down = NUL; 
.................... 	// rec_wait = NUL; 
.................... 	event_wake = E_LIS_WS1; 
.................... 	print_debug(event_wake); 
.................... 	return event_wake; 
.................... } 
.................... void setLang(char _whatLang){	//set the language based on the argument passed 
0388:  CLRF   73
.................... 	char _rec_setlang = NUL; 
.................... 	while (_rec_setlang != STS_SUCCESS){ 
038A:  MOVF   73,W
038C:  SUBLW  6F
038E:  BZ    03B0
.................... 		fputc(CMD_LANGUAGE,EVR); 
0390:  MOVLW  6C
0392:  RCALL  02DE
.................... 		ms25(); 
0394:  RCALL  030E
.................... 		fputc(_whatLang,EVR); 
0396:  MOVF   72,W
0398:  RCALL  02DE
.................... 		ms25(); 
039A:  RCALL  030E
.................... 		if (kbhit(EVR)) _rec_setlang = fgetc(EVR); 
039C:  BTFSS  F9E.5
039E:  BRA    03A8
03A0:  BTFSS  F9E.5
03A2:  BRA    03A0
03A4:  MOVFF  FAE,73
.................... 		print_debug(_rec_setlang); 
03A8:  MOVFF  73,74
03AC:  RCALL  0358
03AE:  BRA    038A
.................... 	} 
03B0:  GOTO   0B2E (RETURN)
.................... } 
.................... void setTimeout(char _period){	//set a period of the timeout based on the argument passed 
03B4:  CLRF   73
.................... 	char _rec_time = NUL; 
.................... 	while (_rec_time != STS_SUCCESS){ 
03B6:  MOVF   73,W
03B8:  SUBLW  6F
03BA:  BZ    03DC
.................... 		fputc(CMD_TIMEOUT,EVR); 
03BC:  MOVLW  6F
03BE:  RCALL  02DE
.................... 		ms25(); 
03C0:  RCALL  030E
.................... 		fputc(_period,EVR); 
03C2:  MOVF   72,W
03C4:  RCALL  02DE
.................... 		ms25(); 
03C6:  RCALL  030E
.................... 		if (kbhit(EVR)) _rec_time = fgetc(EVR); 
03C8:  BTFSS  F9E.5
03CA:  BRA    03D4
03CC:  BTFSS  F9E.5
03CE:  BRA    03CC
03D0:  MOVFF  FAE,73
.................... 		print_debug(_rec_time); 
03D4:  MOVFF  73,74
03D8:  RCALL  0358
03DA:  BRA    03B6
.................... 	} 
03DC:  GOTO   0B34 (RETURN)
.................... } 
....................  
.................... //***********State Fns**********// 
.................... /* int listenWS1(){	//listens to wordset1 and determines which word was spoken 
.................... 	char rec_WS1 = NUL; 
.................... 	char cmd_WS1 = NUL; 
.................... 	int event_WS1 = 0; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
.................... 	ms25(); 
.................... 	fputc(ARG_ONE,EVR); 
.................... 	ms25(); 
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
.................... 	if (kbhit()) rec_WS1 = fgetc(EVR); 
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
.................... 	if (rec_WS1 == STS_SIMILAR){ 
.................... 		fputc(ARG_ACK,EVR); 
.................... 		ms25(); 
.................... 		rec_WS1 = NUL; 
.................... 		rec_WS1 = fgetc(EVR); 
.................... 		cmd_WS1 = rec_WS1 - ARG_ZERO; 
.................... 		print_debug(cmd_WS1); 
.................... 		switch (cmd_WS1){ 
.................... 			case WS1_ACTION: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_MOVE: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_TURN: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_RUN: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_LOOK: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_ATTACK: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_STOP: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			case WS1_HELLO: 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 			default:	 
.................... 					event_WS1 = E_LIS_GP1; 
.................... 				break; 
.................... 		} 
.................... 		return event_WS1; 
.................... 	}else 
.................... 	if (rec_WS1 == STS_TIMEOUT){ 
.................... 			blinkD2(3); //timeout indicator 
.................... 			event_WS1 = E_LIS_WS1; //restart listening procedure 
.................... 		return event_WS1; 
.................... 	}else 
.................... 	if (rec_WS1 == STS_ERROR){ 
.................... 			blinkD2(3); //error indicator 
.................... 			event_WS1 = E_LIS_WS1; //restart listening procedure 
.................... 		return event_WS1; 
.................... 	} 
.................... } 
....................  */ 
.................... /*void listenWS2(){	//listens to wordset2 and determines which word was spoken 
.................... 	char rec_WS2 = NUL; 
.................... 	char cmd_WS2 = NUL; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
.................... 	ms25(); 
.................... 	fputc(ARG_TWO,EVR); 
.................... 	ms25(); 
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
.................... 	if (kbhit()) rec_WS2 = fgetc(EVR); 
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
.................... 	if (rec_WS2 == STS_SIMILAR){ 
.................... 		fputc(ARG_ACK,EVR); 
.................... 		ms25(); 
.................... 		rec_WS2 = NUL; 
.................... 		rec_WS2 = fgetc(EVR); 
.................... 		cmd_WS2 = rec_WS2 - ARG_ZERO; 
.................... 		switch (cmd_WS2){ 
.................... 			case WS2_LEFT: 
.................... 				break; 
.................... 			case WS2_RIGHT: 
.................... 				break; 
.................... 			case WS2_UP: 
.................... 				break;	 
.................... 			case WS2_DOWN: 
.................... 				break; 
.................... 			case WS2_FORWARD: 
.................... 				break; 
.................... 			case WS2_BACKWARD: 
.................... 				break; 
.................... 			default:	rec_WS2 = STS_SIMILAR; 
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
.................... 	if (rec_WS2 == STS_TIMEOUT){ 
.................... 		break; 
.................... 	}else 
.................... 	if (rec_WS2 == STS_ERROR){ 
.................... 		break; 
.................... 	} 
.................... } 
.................... void listenWS3(){	//listens to wordset3 and determines which word was spoken 
.................... 	char rec_WS3 = NUL; 
.................... 	char cmd_WS3 = NUL; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
.................... 	ms25(); 
.................... 	fputc(ARG_THREE,EVR); 
.................... 	ms25(); 
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
.................... 	if (kbhit()) rec_WS3 = fgetc(EVR); 
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
.................... 	if (rec_WS3 == STS_SIMILAR){ 
.................... 		fputc(ARG_ACK,EVR); 
.................... 		ms25(); 
.................... 		rec_WS3 = NUL; 
.................... 		rec_WS3 = fgetc(EVR); 
.................... 		cmd_WS3 = rec_WS3 - ARG_ZERO; 
.................... 		switch (cmd_WS3){ 
.................... 			case WS3_ZERO: 
.................... 				break; 
.................... 			case WS3_ONE: 
.................... 				blinkA0(1); 
.................... 				break; 
.................... 			case WS3_TWO: 
.................... 				break; 
.................... 			case WS3_THREE: 
.................... 				break; 
.................... 			case WS3_FOUR: 
.................... 				break; 
.................... 			case WS3_FIVE: 
.................... 				break; 
.................... 			case WS3_SIX: 
.................... 				break; 
.................... 			case WS3_SEVEN: 
.................... 				break; 
.................... 			case WS3_EIGHT: 
.................... 				break; 
.................... 			case WS3_NINE: 
.................... 				break; 
.................... 			case WS3_TEN: 
.................... 				break; 
.................... 			default:		rec_WS3 = STS_SIMILAR; 
.................... 				break; 
.................... 		} 
.................... 		break; 
.................... 	}else 
.................... 	if (rec_WS3 == STS_TIMEOUT){ 
.................... 		break; 
.................... 	}else 
.................... 	if (rec_WS3 == STS_ERROR){ 
.................... 		break; 
.................... 	} 
.................... } 
.................... */ 
.................... /* int listenGP1(){	//listens to group1 and determines which word was spoken 
.................... 	char rec_GP1 = NUL; 
.................... 	char cmd_GP1 = NUL; 
.................... 	int event_GP1 = 0; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
.................... 	ms25(); 
.................... 	fputc(ARG_ONE,EVR); 
.................... 	ms25(); 
.................... 	output_high(PIN_A0);//indicate that the device is listening 
.................... 	if (kbhit()) rec_GP1 = fgetc(EVR); 
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
.................... 	if (rec_GP1 == STS_SIMILAR){ 
.................... 		fputc(ARG_ACK,EVR); 
.................... 		ms25(); 
.................... 		rec_GP1 = NUL; 
.................... 		rec_GP1 = fgetc(EVR); 
.................... 		cmd_GP1 = rec_GP1 - ARG_ZERO; 
.................... 		switch (cmd_GP1){ 
.................... 			case G1_CALL: 
.................... 					event_GP1 = E_LIS_GP2; 
.................... 				break; 
.................... 			case G1_ANSWER: 
.................... 					fprintf(GSM,ansCall); //send a command to the GSM module to answer the call 
.................... 					blinkD2(1); 
.................... 					event_GP1 = E_LIS_GP2; 
.................... 				break; 
.................... 			case G1_LIGHTS: 
.................... 					event_GP1 = E_LIS_GP2; 
.................... 					messages = G1_LIGHTS; 
.................... 					//go to group 2 to perform action 
.................... 				break; 
.................... 			case G1_LED: 
.................... 					event_GP1 = E_LIS_GP2; 
.................... 					messages = G1_LED; 
.................... 					//go to group 2 to perform action 
.................... 				break; 
.................... 			case G1_OTHER: 
.................... 					event_GP1 = E_LIS_GP2; 
.................... 					//go to group 2 to perform action 
.................... 				break; 
.................... 			case G1_END: 
.................... 					fprintf(GSM,endCall); //send a command to the GSM module to end the call 
.................... 					event_GP1 = E_END; 
.................... 				break; 
.................... 			default: 
.................... 					event_GP1 = E_LIS_GP2; 
.................... 				break; 
.................... 		} 
.................... 		return event_GP1; 
.................... 	}else 
.................... 	if (rec_GP1 == STS_TIMEOUT){ 
.................... 			blinkD2(3); //timeout indicator 
.................... 			event_GP1 = E_LIS_GP1; //restart listening procedure 
.................... 		return event_GP1; 
.................... 	}else 
.................... 	if (rec_GP1 == STS_ERROR){ 
.................... 			blinkD2(3); //error indicator 
.................... 			event_GP1 = E_LIS_GP1; //restart listening procedure 
.................... 		return event_GP1; 
.................... 	} 
....................  
.................... } 
.................... int listenGP2(){	//listens to group2 and determines which word was spoken 
.................... 	char rec_GP2 = NUL; 
.................... 	char cmd_GP2 = NUL; 
.................... 	int event_GP2 = 0; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
.................... 	ms25(); 
.................... 	fputc(ARG_TWO,EVR); 
.................... 	ms25(); 
.................... 	output_high(PIN_A0);//indicate that the device is listening 
.................... 	if (kbhit()) rec_GP2 = fgetc(EVR); 
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
.................... 	if (rec_GP2 == STS_SIMILAR){ 
.................... 		fputc(ARG_ACK,EVR); 
.................... 		ms25(); 
.................... 		rec_GP2 = NUL; 
.................... 		rec_GP2 = fgetc(EVR); 
.................... 		cmd_GP2 = rec_GP2 - ARG_ZERO; 
.................... 		switch (cmd_GP2){ 
.................... 			case G2_DOCTOR: 
.................... 					playback(SND_calling); 
.................... 					blinkD2(2); 
.................... 					event_GP2 = E_CALL_SENT; 
.................... 				break; 
.................... 			case G2_PARENT: 
.................... 					playback(SND_calling); 
.................... 					blinkD2(2); 
.................... 					event_GP2 = E_CALL_SENT; 
.................... 				break; 
.................... 			case G2_MOM: 
.................... 					playback(SND_calling); 
.................... 					blinkD2(2); 
.................... 					event_GP2 = E_CALL_SENT; 
.................... 				break; 
.................... 			case G2_DAD: 
.................... 					playback(SND_calling); 
.................... 					blinkD2(2); 
.................... 					event_GP2 = E_CALL_SENT; 
.................... 				break; 
.................... 			case G2_SON: 
.................... 					playback(SND_calling); 
.................... 					blinkD2(2); 
.................... 					event_GP2 = E_CALL_SENT; 
.................... 				break; 
.................... 			case G2_DAUGHTER: 
.................... 					playback(SND_calling); 
.................... 					blinkD2(2); 
.................... 					event_GP2 = E_CALL_SENT; 
.................... 				break; 
.................... 			case G2_ON: 
.................... 					if (messages == G1_LIGHTS){ 
.................... 						playback(SND_turning_on_light_bulb); 
.................... 						output_high(PIN_D2); 
.................... 					} 
.................... 					else 
.................... 					if (messages == G1_LED){ 
.................... 						playback(SND_turning_on_LED); 
.................... 						output_high(PIN_A1); 
.................... 					} 
.................... 					messages = 0; //clear messages 
.................... 					event_GP2 = E_TASK_FINISHED; 
.................... 				break; 
.................... 			case G2_OFF: 
.................... 					if (messages == G1_LIGHTS){ 
.................... 						playback(SND_turning_off_light_bulb); 
.................... 						output_low(PIN_D2); 
.................... 					} 
.................... 					else 
.................... 					if (messages == G1_LED){ 
.................... 						playback(SND_turning_off_LED); 
.................... 						output_low(PIN_A1); 
.................... 					} 
.................... 					messages = 0; //clear messages 
.................... 					event_GP2 = E_TASK_FINISHED; 
.................... 				break; 
.................... 			case G2_OTHER: 
.................... 					event_GP2 = E_LIS_NUMS; 
.................... 				break; 
.................... 			default: 
.................... 					event_GP2 = E_TASK_FINISHED; 
.................... 				break; 
.................... 		} 
.................... 		return event_GP2; 
.................... 	}else 
.................... 	if (rec_GP2 == STS_TIMEOUT){ 
.................... 			blinkD2(3); 
.................... 			event_GP2 = E_LIS_GP2; 
.................... 		return event_GP2; 
.................... 	}else 
.................... 	if (rec_GP2 == STS_ERROR){ 
.................... 			blinkD2(3); 
.................... 			event_GP2 = E_LIS_GP2; 
.................... 		return event_GP2; 
.................... 	} 
.................... } 
.................... int listenGP3(){	//listens to group3 and determines which word was spoken 
.................... 	char rec_GP3 = NUL; 
.................... 	char cmd_GP3 = NUL; 
.................... 	int number; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
.................... 	ms25(); 
.................... 	fputc(ARG_THREE,EVR); 
.................... 	ms25(); 
.................... 	output_high(PIN_A0);	//indicate that the device is listening 
.................... 	if (kbhit()) rec_GP3 = fgetc(EVR); 
.................... 	output_low(PIN_A0);		//indicate that the device has stopped listening 
.................... 	if (rec_GP3 == STS_SIMILAR){ 
.................... 		fputc(ARG_ACK,EVR); 
.................... 		ms25(); 
.................... 		rec_GP3 = NUL; 
.................... 		rec_GP3 = fgetc(EVR); 
.................... 		cmd_GP3 = rec_GP3 - ARG_ZERO; 
.................... 		switch (cmd_GP3){ 
.................... 			case G3_ZERO: 
.................... 				number = 0x30; 
.................... 				break; 
.................... 			case G3_ONE: 
.................... 				number = 0x31; 
.................... 				break; 
.................... 			case G3_TWO: 
.................... 				number = 0x32; 
.................... 				break; 
.................... 			case G3_THREE: 
.................... 				number = 0x33; 
.................... 				break; 
.................... 			case G3_FOUR: 
.................... 				number = 0x34; 
.................... 				break; 
.................... 			case G3_FIVE: 
.................... 				number = 0x35; 
.................... 				break; 
.................... 			case G3_SIX: 
.................... 				number = 0x36; 
.................... 				break; 
.................... 			case G3_SEVEN: 
.................... 				number = 0x37; 
.................... 				break; 
.................... 			case G3_EIGHT: 
.................... 				number = 0x38; 
.................... 				break; 
.................... 			case G3_NINE: 
.................... 				number = 0x39; 
.................... 				break; 
.................... 			// case G3_TEN: 
.................... 				// number = 10; 
.................... 				// break; 
.................... 			default: 
.................... 				number = error; 
.................... 				break; 
.................... 		} 
.................... 		return number; 
.................... 	}else 
.................... 	if (rec_GP3 == STS_TIMEOUT){ 
.................... 		return error; 
.................... 	}else 
.................... 	if (rec_GP3 == STS_ERROR){ 
.................... 		return error; 
.................... 	} 
.................... } 
....................  */ 
....................  
.................... //***********State Fns**********// these are some new functions based on what I realised last night 
.................... char listenWS1(){ 
03E0:  CLRF   72
.................... 	char rec_WS1 = NUL; 
.................... 	fputc(CMD_RECOG_SI,EVR); 
03E2:  MOVLW  69
03E4:  RCALL  02DE
.................... 	ms25(); 
03E6:  RCALL  030E
.................... 	fputc(ARG_ONE,EVR); 
03E8:  MOVLW  42
03EA:  RCALL  02DE
.................... 	ms25(); 
03EC:  RCALL  030E
.................... 	output_high(PIN_D2);	//indicate that the device is listening 
03EE:  BCF    F95.2
03F0:  BSF    F8C.2
.................... 	if (kbhit()) rec_WS1 = fgetc(EVR); 
03F2:  BTFSS  F9E.5
03F4:  BRA    03FE
03F6:  BTFSS  F9E.5
03F8:  BRA    03F6
03FA:  MOVFF  FAE,72
.................... 	output_low(PIN_D2);		//indicate that the device has stopped listening 
03FE:  BCF    F95.2
0400:  BCF    F8C.2
.................... 	return rec_WS1; 
0402:  MOVFF  72,01
0406:  GOTO   0B3A (RETURN)
.................... } 
....................  
.................... char listenGP1(){ 
*
0936:  CLRF   72
.................... 	char rec_GP1 = NUL; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
0938:  MOVLW  64
093A:  RCALL  02DE
.................... 	ms25(); 
093C:  RCALL  030E
.................... 	fputc(ARG_ONE,EVR); 
093E:  MOVLW  42
0940:  RCALL  02DE
.................... 	ms25(); 
0942:  RCALL  030E
.................... 	output_high(PIN_D2);//indicate that the device is listening 
0944:  BCF    F95.2
0946:  BSF    F8C.2
.................... 	if (kbhit()) rec_GP1 = fgetc(EVR); 
0948:  BTFSS  F9E.5
094A:  BRA    0954
094C:  BTFSS  F9E.5
094E:  BRA    094C
0950:  MOVFF  FAE,72
.................... 	output_low(PIN_D2);		//indicate that the device has stopped listening 
0954:  BCF    F95.2
0956:  BCF    F8C.2
.................... 	return rec_GP1; 
0958:  MOVFF  72,01
095C:  GOTO   0BD6 (RETURN)
.................... } 
.................... char listenGP2(){ 
*
0982:  CLRF   72
.................... 	char rec_GP2 = NUL; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
0984:  MOVLW  64
0986:  RCALL  02DE
.................... 	ms25(); 
0988:  RCALL  030E
.................... 	fputc(ARG_TWO,EVR); 
098A:  MOVLW  43
098C:  RCALL  02DE
.................... 	ms25(); 
098E:  RCALL  030E
.................... 	output_high(PIN_D2);//indicate that the device is listening 
0990:  BCF    F95.2
0992:  BSF    F8C.2
.................... 	if (kbhit()) rec_GP2 = fgetc(EVR); 
0994:  BTFSS  F9E.5
0996:  BRA    09A0
0998:  BTFSS  F9E.5
099A:  BRA    0998
099C:  MOVFF  FAE,72
.................... 	output_low(PIN_D2);		//indicate that the device has stopped listening 
09A0:  BCF    F95.2
09A2:  BCF    F8C.2
.................... 	return rec_GP2; 
09A4:  MOVFF  72,01
09A8:  GOTO   0C4C (RETURN)
.................... } 
.................... char listenGP3(){ 
09AC:  CLRF   72
.................... 	char rec_GP3 = NUL; 
.................... 	fputc(CMD_RECOG_SD,EVR); 
09AE:  MOVLW  64
09B0:  RCALL  02DE
.................... 	ms25(); 
09B2:  RCALL  030E
.................... 	fputc(ARG_THREE,EVR); 
09B4:  MOVLW  44
09B6:  RCALL  02DE
.................... 	ms25(); 
09B8:  RCALL  030E
.................... 	output_high(PIN_D2);	//indicate that the device is listening 
09BA:  BCF    F95.2
09BC:  BSF    F8C.2
.................... 	if (kbhit()) rec_GP3 = fgetc(EVR); 
09BE:  BTFSS  F9E.5
09C0:  BRA    09CA
09C2:  BTFSS  F9E.5
09C4:  BRA    09C2
09C6:  MOVFF  FAE,72
.................... 	output_low(PIN_D2);		//indicate that the device has stopped listening 
09CA:  BCF    F95.2
09CC:  BCF    F8C.2
.................... 	return rec_GP3; 
09CE:  MOVFF  72,01
09D2:  GOTO   0D14 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //                   ========================                    // 
.................... //===================S T A T E  M A C H I N E====================// 
.................... //                   ========================                    // 
.................... //						     STRUCTURE	     					 // 
.................... /* void StateMachine(){ 
.................... 	int current_state = S_WAIT; 
.................... 	int event_outcome; 
.................... 	char ph_number[8]; 
.................... 	int num_idx = 0; 
.................... 	int count; 
.................... 	char temp; 
.................... 	 
.................... 	switch(current_state){ 
.................... 		case S_WAIT: 
.................... 				event_outcome = wait(); 
.................... 				switch(event_outcome){ 
.................... 					case E_LIS_WS1: 
.................... 							current_state = S_WS1; 
.................... 						break; 
.................... 					case E_ANS_CALL: 
.................... 							current_state = S_GP1; 
.................... 						break; 
.................... 					case E_END_CALL: 
.................... 							current_state = S_GP1; 
.................... 						break; 
.................... 					default: 
.................... 						blinkD2(4); //severe error if this happens, will restart this state 
.................... 						current_state = S_WAIT; 
.................... 						break; 
.................... 				} 
.................... 			break; 
.................... 		case S_WS1: 
.................... 				event_outcome = listenWS1(); 
.................... 				switch(event_outcome){ 
.................... 					case E_LIS_GP1: 
.................... 						current_state = S_GP2; 
.................... 						break; 
.................... 					default: 
.................... 						blinkD2(4); //severe error if this happens, will restart this state 
.................... 						current_state = S_WS1; 
.................... 						break; 
.................... 				} 
.................... 			break; 
.................... 		case S_GP1: 
.................... 				event_outcome = listenGP1(); 
.................... 				switch(event_outcome){ 
.................... 					case E_LIS_GP2: 
.................... 						current_state = S_GP2; 
.................... 						break; 
.................... 					case E_END: 
.................... 						current_state = S_WAIT; 
.................... 						break; 
.................... 					default: 
.................... 						blinkD2(4); //severe error if this happens, will restart this state 
.................... 						current_state = S_GP1; 
.................... 						break; 
.................... 				} 
.................... 			break; 
.................... 		case S_GP2: 
.................... 				event_outcome = listenGP2(); 
.................... 				switch(event_outcome){ 
.................... 					case E_TASK_FINISHED: 
.................... 						current_state = S_WAIT; 
.................... 						break; 
.................... 					case E_CALL_SENT: 
.................... 						current_state = S_WAIT; 
.................... 						break; 
.................... 					case E_LIS_NUMS: 
.................... 						current_state = S_NUMBERS; 
.................... 						break; 
.................... 					default: 
.................... 						blinkD2(4); //severe error if this happens, will restart this state 
.................... 						current_state = S_GP2; 
.................... 						break; 
.................... 				} 
.................... 			break; 
.................... 		case S_NUMBERS: 
.................... 				for (count = 0; count == 6; count++){ 
.................... 					temp = listenGP3(); 
.................... 					ph_number[num_idx] = temp; 
.................... 				} 
.................... 				ph_number[7] = "\0"; //add the null character  
.................... 				strcat(dial,ph_number); 
.................... 				strcat(dial,end); 
.................... 				fputs(dial,GSM); 
.................... 				count = 0; //reset the counter variable 
.................... 				event_outcome = E_CALL_SENT; 
.................... 			break; 
.................... 	} 
.................... } 
....................  */ 
....................  
....................  
.................... //                      =================                       // 
.................... //======================I N T E R U P T S=======================// 
.................... //                      =================                       // 
.................... volatile int incoming_call = FALSE; 
.................... #INT_EXT 
.................... void detect_call(void){ 
.................... 	enable_interrupts(INT_TIMER1); 
*
00DE:  BSF    F9D.0
.................... 	incoming_call = TRUE; 
00E0:  MOVLW  01
00E2:  MOVWF  64
.................... } 
....................  
00E4:  BCF    FF2.1
00E6:  GOTO   0090
.................... #INT_EXT1 
.................... void button2(void){ 
*
014A:  CLRF   7C
014C:  CLRF   7B
.................... 	int16 b = 0; 
.................... 	disable_interrupts(INT_TIMER1); 
014E:  BCF    F9D.0
.................... 	fputs("ATD+18686822015;",GSM); 
0150:  MOVLW  8C
0152:  MOVWF  FF6
0154:  MOVLW  01
0156:  MOVWF  FF7
0158:  RCALL  012A
015A:  MOVLW  0D
015C:  MOVWF  7F
015E:  RCALL  00EA
0160:  MOVLW  0A
0162:  MOVWF  7F
0164:  RCALL  00EA
.................... 	for (b;b<500;b++)delay_cycles(255); 
0166:  MOVF   7C,W
0168:  SUBLW  01
016A:  BNC   0186
016C:  BNZ   0174
016E:  MOVF   7B,W
0170:  SUBLW  F3
0172:  BNC   0186
0174:  MOVLW  54
0176:  MOVWF  00
0178:  DECFSZ 00,F
017A:  BRA    0178
017C:  BRA    017E
017E:  INCF   7B,F
0180:  BTFSC  FD8.2
0182:  INCF   7C,F
0184:  BRA    0166
.................... } 
....................  
0186:  BCF    FF0.0
0188:  GOTO   0090
.................... #INT_EXT2 
.................... void button1(void){ // answering and ending calls 
*
019E:  CLRF   7C
01A0:  CLRF   7B
.................... 	int16 a = 0; 
.................... 	switch (incoming_call){ 
01A2:  MOVF   64,W
01A4:  XORLW  01
01A6:  BZ    01AE
01A8:  XORLW  01
01AA:  BZ    01CA
01AC:  BRA    01E2
.................... 		case TRUE: 
.................... 			disable_interrupts(INT_TIMER1); 
01AE:  BCF    F9D.0
.................... 			fputs("ATA\r\n",GSM); 
01B0:  MOVLW  08
01B2:  MOVWF  FF6
01B4:  MOVLW  02
01B6:  MOVWF  FF7
01B8:  RCALL  012A
01BA:  MOVLW  0D
01BC:  MOVWF  7F
01BE:  RCALL  00EA
01C0:  MOVLW  0A
01C2:  MOVWF  7F
01C4:  RCALL  00EA
.................... 			incoming_call = FALSE; // clear the incoming flag 
01C6:  CLRF   64
.................... 		break; 
01C8:  BRA    01E2
.................... 		case FALSE: 
.................... 			disable_interrupts(INT_TIMER1); 
01CA:  BCF    F9D.0
.................... 			fputs("ATH\r\n",GSM); 
01CC:  MOVLW  0E
01CE:  MOVWF  FF6
01D0:  MOVLW  02
01D2:  MOVWF  FF7
01D4:  RCALL  012A
01D6:  MOVLW  0D
01D8:  MOVWF  7F
01DA:  RCALL  00EA
01DC:  MOVLW  0A
01DE:  MOVWF  7F
01E0:  RCALL  00EA
.................... 		break; 
.................... 	} 
.................... 	for (a;a<500;a++)delay_cycles(255); 
01E2:  MOVF   7C,W
01E4:  SUBLW  01
01E6:  BNC   0202
01E8:  BNZ   01F0
01EA:  MOVF   7B,W
01EC:  SUBLW  F3
01EE:  BNC   0202
01F0:  MOVLW  54
01F2:  MOVWF  00
01F4:  DECFSZ 00,F
01F6:  BRA    01F4
01F8:  BRA    01FA
01FA:  INCF   7B,F
01FC:  BTFSC  FD8.2
01FE:  INCF   7C,F
0200:  BRA    01E2
.................... } 
....................  
0202:  BCF    FF0.1
0204:  GOTO   0090
.................... #INT_TIMER0 
.................... void live(){ 
.................... 	output_toggle(PIN_A0); 
*
0214:  BCF    F92.0
0216:  BTG    F89.0
.................... } 
....................  
0218:  BCF    FF2.2
021A:  GOTO   0090
.................... #INT_TIMER1 
.................... void call_signal(void){ 
021E:  CLRF   7C
0220:  CLRF   7B
.................... 	int16 c = 0; 
.................... 	output_high(PIN_D0); //pulse buzzer for incoming call 
0222:  BCF    F95.0
0224:  BSF    F8C.0
.................... 	for (c;c<1000;c++)delay_cycles(255); 
0226:  MOVF   7C,W
0228:  SUBLW  03
022A:  BNC   0246
022C:  BNZ   0234
022E:  MOVF   7B,W
0230:  SUBLW  E7
0232:  BNC   0246
0234:  MOVLW  54
0236:  MOVWF  00
0238:  DECFSZ 00,F
023A:  BRA    0238
023C:  BRA    023E
023E:  INCF   7B,F
0240:  BTFSC  FD8.2
0242:  INCF   7C,F
0244:  BRA    0226
.................... 	output_low(PIN_D0); 
0246:  BCF    F95.0
0248:  BCF    F8C.0
.................... 	// output_toggle(PIN_A0); 
024A:  BCF    F9E.0
024C:  GOTO   0090
.................... } 
....................  
....................  
....................  
.................... //                            =======                           // 
.................... //============================M A I N===========================// 
.................... //                            =======                           // 
.................... void main(){ 
*
0A40:  CLRF   FF8
0A42:  BCF    FD0.7
0A44:  BSF    07.7
0A46:  BCF    FB8.3
0A48:  MOVLW  40
0A4A:  MOVWF  FAF
0A4C:  MOVLW  A6
0A4E:  MOVWF  FAC
0A50:  MOVLW  90
0A52:  MOVWF  FAB
0A54:  BCF    F94.4
0A56:  BSF    F8B.4
0A58:  BCF    F92.4
0A5A:  BSF    F89.4
0A5C:  CLRF   21
0A5E:  CLRF   20
0A60:  CLRF   64
0A62:  MOVF   FC1,W
0A64:  ANDLW  C0
0A66:  IORLW  0F
0A68:  MOVWF  FC1
0A6A:  MOVLW  07
0A6C:  MOVWF  FB4
0A6E:  BRA    0AB2
0A70:  DATA 02,00
0A72:  DATA 1A,00
0A74:  DATA 00,34
0A76:  DATA 00,22
0A78:  DATA 41,54
0A7A:  DATA 0D,0A
0A7C:  DATA 00,41
0A7E:  DATA 54,26
0A80:  DATA 57,0D
0A82:  DATA 0A,00
0A84:  DATA 41,54
0A86:  DATA 45,30
0A88:  DATA 0D,0A
0A8A:  DATA 00,41
0A8C:  DATA 54,2B
0A8E:  DATA 43,4D
0A90:  DATA 47,46
0A92:  DATA 3D,31
0A94:  DATA 0D,0A
0A96:  DATA 00,41
0A98:  DATA 54,48
0A9A:  DATA 0D,0A
0A9C:  DATA 00,41
0A9E:  DATA 54,41
0AA0:  DATA 0D,0A
0AA2:  DATA 00,41
0AA4:  DATA 54,44
0AA6:  DATA 2B,31
0AA8:  DATA 38,36
0AAA:  DATA 38,00
0AAC:  DATA 02,00
0AAE:  DATA 61,3B
0AB0:  DATA 00,00
0AB2:  MOVLW  00
0AB4:  MOVWF  FF8
0AB6:  MOVLW  0A
0AB8:  MOVWF  FF7
0ABA:  MOVLW  70
0ABC:  MOVWF  FF6
0ABE:  TBLRD*+
0AC0:  MOVF   FF5,W
0AC2:  MOVWF  00
0AC4:  XORLW  00
0AC6:  BZ    0AEE
0AC8:  TBLRD*+
0ACA:  MOVF   FF5,W
0ACC:  MOVWF  01
0ACE:  BTFSC  FE8.7
0AD0:  BRA    0ADC
0AD2:  ANDLW  0F
0AD4:  MOVWF  FEA
0AD6:  TBLRD*+
0AD8:  MOVFF  FF5,FE9
0ADC:  BTFSC  01.6
0ADE:  TBLRD*+
0AE0:  BTFSS  01.6
0AE2:  TBLRD*+
0AE4:  MOVFF  FF5,FEE
0AE8:  DCFSNZ 00,F
0AEA:  BRA    0ABE
0AEC:  BRA    0AE0
0AEE:  CLRF   FF8
.................... //INTERRUPT SETUP	 
.................... 	SET_TRIS_B(0x0F);				// set lower half of port B as input 
0AF0:  MOVLW  0F
0AF2:  MOVWF  F93
.................... 	ext_int_edge(H_TO_L);			// 
0AF4:  BCF    FF1.6
.................... 	ext_int_edge(1,H_TO_L);			// set up the trigger level for interrupts 
0AF6:  BCF    FF1.5
.................... 	ext_int_edge(2,H_TO_L);			// 
0AF8:  BCF    FF1.4
.................... 	 
.................... 	clear_interrupt(INT_EXT);		// 
0AFA:  BCF    FF2.1
.................... 	clear_interrupt(INT_EXT1);		// clear interrupts on start up...so no more problems would happen 
0AFC:  BCF    FF0.0
.................... 	clear_interrupt(INT_EXT2);		// 
0AFE:  BCF    FF0.1
.................... 	clear_interrupt(INT_TIMER0);	// 
0B00:  BCF    FF2.2
.................... 	clear_interrupt(INT_TIMER1);	// 
0B02:  BCF    F9E.0
.................... 	 
.................... 	// setup_timer_0(RTCC_INTERNAL|RTCC_DIV_64);//1.6 s overflow 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32);//840 ms overflow 
0B04:  MOVLW  84
0B06:  MOVWF  FD5
.................... 	setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//209 ms overflow 
0B08:  MOVLW  B5
0B0A:  MOVWF  FCD
.................... 	enable_interrupts(INT_TIMER0); 
0B0C:  BSF    FF2.5
.................... 	enable_interrupts(INT_EXT);		// 
0B0E:  BSF    FF2.4
.................... 	enable_interrupts(INT_EXT1);	// enable all the external interrupts 
0B10:  BSF    FF0.3
.................... 	enable_interrupts(INT_EXT2);	// 
0B12:  BSF    FF0.4
.................... 	enable_interrupts(GLOBAL);		// enable golbal interrutps 
0B14:  MOVLW  C0
0B16:  IORWF  FF2,F
.................... 	 
.................... //SOME VARIABLES 
.................... 	char listening_status = NUL; 
.................... 	char command_is = NUL; 
.................... 	char receive = NUL; 
.................... 	int test = FALSE; 
.................... 	 
.................... 	int count = 0; 
.................... 	char ph_number[8]; 
0B18:  CLRF   65
0B1A:  CLRF   66
0B1C:  CLRF   67
0B1E:  CLRF   68
0B20:  CLRF   69
.................... 	 
.................... //GSM SETUP 
.................... 	gsmSetup(); 
0B22:  GOTO   0292
.................... 	 
.................... //VOICE RECOG SETUP 
.................... 	stop_EVR(); 
0B26:  BRA    0360
.................... 	setLang(ARG_ONE);//set language recog to english 
0B28:  MOVLW  42
0B2A:  MOVWF  72
0B2C:  BRA    0388
.................... 	setTimeout(ARG_FIVE);//set timeout to be 5 seconds 
0B2E:  MOVLW  46
0B30:  MOVWF  72
0B32:  BRA    03B4
.................... 	 
.................... 	 
.................... //PROGRAM FLOW 
.................... while(TRUE){ 
.................... 	 
.................... 	// go_to_sleep(); 
.................... 	// wait(); 
.................... //start of first state 
.................... if (test == STATE1){ 
0B34:  MOVF   68,F
0B36:  BNZ   0BD0
.................... 	//calling function to listen to wordset 1 
....................  	listening_status = listenWS1(); 
0B38:  BRA    03E0
0B3A:  MOVFF  01,65
.................... 	switch(listening_status){ 
0B3E:  MOVF   65,W
0B40:  XORLW  73
0B42:  BZ    0B4E
0B44:  XORLW  07
0B46:  BZ    0BC2
0B48:  XORLW  11
0B4A:  BZ    0BCA
0B4C:  BRA    0BD0
.................... 		case STS_SIMILAR: // this must be used to for listening for SI commands 
.................... 		fputc(ARG_ACK,EVR); 
0B4E:  MOVLW  20
0B50:  CALL   02DE
.................... 		ms25(); 
0B54:  CALL   030E
.................... 		receive = fgetc(EVR); 
0B58:  BTFSS  F9E.5
0B5A:  BRA    0B58
0B5C:  MOVFF  FAE,67
.................... 		command_is = receive - ARG_ZERO; 
0B60:  MOVLW  41
0B62:  SUBWF  67,W
0B64:  MOVWF  66
.................... 		switch (command_is){ 
0B66:  MOVF   66,W
0B68:  BZ    0B88
0B6A:  XORLW  01
0B6C:  BZ    0B94
0B6E:  XORLW  03
0B70:  BZ    0B96
0B72:  XORLW  01
0B74:  BZ    0B98
0B76:  XORLW  07
0B78:  BZ    0BA4
0B7A:  XORLW  01
0B7C:  BZ    0BA6
0B7E:  XORLW  03
0B80:  BZ    0BA8
0B82:  XORLW  01
0B84:  BZ    0BAA
0B86:  BRA    0BB6
.................... 			case WS1_ACTION: 
.................... 					blinkD2(1); 
0B88:  MOVLW  01
0B8A:  MOVWF  72
0B8C:  RCALL  040A
.................... 					test = STATE2; 
0B8E:  MOVLW  01
0B90:  MOVWF  68
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0B92:  BRA    0BC0
.................... 			case WS1_MOVE: 
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0B94:  BRA    0BC0
.................... 			case WS1_TURN: 
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0B96:  BRA    0BC0
.................... 			case WS1_RUN: 
.................... 					blinkD2(1); 
0B98:  MOVLW  01
0B9A:  MOVWF  72
0B9C:  RCALL  040A
.................... 					test = STATE2; 
0B9E:  MOVLW  01
0BA0:  MOVWF  68
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0BA2:  BRA    0BC0
.................... 			case WS1_LOOK: 
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0BA4:  BRA    0BC0
.................... 			case WS1_ATTACK: 
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0BA6:  BRA    0BC0
.................... 			case WS1_STOP: 
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0BA8:  BRA    0BC0
.................... 			case WS1_HELLO: 
.................... 					blinkD2(1); 
0BAA:  MOVLW  01
0BAC:  MOVWF  72
0BAE:  RCALL  040A
.................... 					test = STATE2; 
0BB0:  MOVLW  01
0BB2:  MOVWF  68
.................... 					// playback(SND_two); // responds to the user 
.................... 					// blinkD2(4); 
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 				break; 
0BB4:  BRA    0BC0
.................... 			default: 
.................... 					playback(SND_please_say_a_command); 
0BB6:  MOVLW  0B
0BB8:  MOVWF  72
0BBA:  RCALL  042C
.................... 					// event_WS1 = E_LIS_GP1; 
.................... 					test = STATE2; 
0BBC:  MOVLW  01
0BBE:  MOVWF  68
.................... 				break; 
.................... 		} 
.................... 		break; 
0BC0:  BRA    0BD0
.................... 		case STS_TIMEOUT: 
.................... 				blinkD2(2); 
0BC2:  MOVLW  02
0BC4:  MOVWF  72
0BC6:  RCALL  040A
.................... 		break; 
0BC8:  BRA    0BD0
.................... 		case STS_ERROR: 
.................... 				blinkD2(3); 
0BCA:  MOVLW  03
0BCC:  MOVWF  72
0BCE:  RCALL  040A
.................... 		break; 
.................... 	}  
.................... }	 
.................... //end of first state 
.................... //start of second state 
.................... if (test == STATE2){ 
0BD0:  DECFSZ 68,W
0BD2:  BRA    0C42
.................... 	// calling function to listen to group 1 
.................... 	listening_status = listenGP1(); 
0BD4:  BRA    0936
0BD6:  MOVFF  01,65
.................... 	switch(listening_status){ 
0BDA:  MOVF   65,W
0BDC:  XORLW  72
0BDE:  BZ    0BEA
0BE0:  XORLW  06
0BE2:  BZ    0C34
0BE4:  XORLW  11
0BE6:  BZ    0C3C
0BE8:  BRA    0C42
.................... 		case STS_RESULT: // this must be used for listening for SD commands 
.................... 		fputc(ARG_ACK,EVR); 
0BEA:  MOVLW  20
0BEC:  CALL   02DE
.................... 		ms25(); 
0BF0:  CALL   030E
.................... 		receive = fgetc(EVR); 
0BF4:  BTFSS  F9E.5
0BF6:  BRA    0BF4
0BF8:  MOVFF  FAE,67
.................... 		command_is = receive - ARG_ZERO; 
0BFC:  MOVLW  41
0BFE:  SUBWF  67,W
0C00:  MOVWF  66
.................... 		switch (command_is){ 
0C02:  MOVF   66,W
0C04:  BZ    0C1C
0C06:  XORLW  01
0C08:  BZ    0C28
0C0A:  XORLW  03
0C0C:  BZ    0C2A
0C0E:  XORLW  01
0C10:  BZ    0C2C
0C12:  XORLW  07
0C14:  BZ    0C2E
0C16:  XORLW  01
0C18:  BZ    0C30
0C1A:  BRA    0C32
.................... 			case G1_CALL: 
.................... 					blinkD0(1); 
0C1C:  MOVLW  01
0C1E:  MOVWF  72
0C20:  RCALL  0960
.................... 					test = STATE3; 
0C22:  MOVLW  02
0C24:  MOVWF  68
.................... 				break; 
0C26:  BRA    0C32
.................... 			case G1_ANSWER:					 
.................... 					// blinkD2(1); 
.................... 				break; 
0C28:  BRA    0C32
.................... 			case G1_LIGHTS: 
.................... 					 
.................... 				break; 
0C2A:  BRA    0C32
.................... 			case G1_LED: 
.................... 					 
.................... 				break; 
0C2C:  BRA    0C32
.................... 			case G1_OTHER: 
.................... 					 
.................... 				break; 
0C2E:  BRA    0C32
.................... 			case G1_END: 
.................... 					 
.................... 				break; 
0C30:  BRA    0C32
.................... 			default: 
.................... 					 
.................... 				break; 
.................... 		} 
.................... 		break; 
0C32:  BRA    0C42
.................... 		case STS_TIMEOUT: 
.................... 			blinkD0(2); 
0C34:  MOVLW  02
0C36:  MOVWF  72
0C38:  RCALL  0960
.................... 		break; 
0C3A:  BRA    0C42
.................... 		case STS_ERROR: 
.................... 			blinkD0(3); 
0C3C:  MOVLW  03
0C3E:  MOVWF  72
0C40:  RCALL  0960
.................... 		break; 
.................... 	} 
.................... } 
.................... //end of second state 
.................... //start of third state 
.................... if (test == STATE3){	 
0C42:  MOVF   68,W
0C44:  SUBLW  02
0C46:  BTFSS  FD8.2
0C48:  BRA    0F26
.................... 	// calling function to listen to group 1 
.................... 	listening_status = listenGP2(); 
0C4A:  BRA    0982
0C4C:  MOVFF  01,65
.................... 	switch(listening_status){	 
0C50:  MOVF   65,W
0C52:  XORLW  72
0C54:  BZ    0C64
0C56:  XORLW  06
0C58:  BTFSC  FD8.2
0C5A:  BRA    0F14
0C5C:  XORLW  11
0C5E:  BTFSC  FD8.2
0C60:  BRA    0F1E
0C62:  BRA    0F26
.................... 		case STS_RESULT: // this must be used for listening for SD comands 
.................... 		fputc(ARG_ACK,EVR); 
0C64:  MOVLW  20
0C66:  CALL   02DE
.................... 		ms25(); 
0C6A:  CALL   030E
.................... 		receive = fgetc(EVR); 
0C6E:  BTFSS  F9E.5
0C70:  BRA    0C6E
0C72:  MOVFF  FAE,67
.................... 		command_is = receive - ARG_ZERO; 
0C76:  MOVLW  41
0C78:  SUBWF  67,W
0C7A:  MOVWF  66
.................... 		switch (command_is){ 
0C7C:  MOVF   66,W
0C7E:  BZ    0CA2
0C80:  XORLW  01
0C82:  BZ    0CA4
0C84:  XORLW  03
0C86:  BZ    0CA6
0C88:  XORLW  01
0C8A:  BZ    0CA8
0C8C:  XORLW  07
0C8E:  BZ    0CAA
0C90:  XORLW  01
0C92:  BZ    0CAC
0C94:  XORLW  03
0C96:  BZ    0CAE
0C98:  XORLW  01
0C9A:  BZ    0CB0
0C9C:  XORLW  0F
0C9E:  BZ    0CB2
0CA0:  BRA    0F0A
.................... 			case G2_DOCTOR: 
.................... 					// playback(SND_calling); 
.................... 					// blinkD2(2); 
.................... 					// event_GP2 = E_CALL_SENT; 
.................... 				break; 
0CA2:  BRA    0F12
.................... 			case G2_PARENT: 
.................... 					// playback(SND_calling); 
.................... 					// blinkD2(2); 
.................... 					// event_GP2 = E_CALL_SENT; 
.................... 				break; 
0CA4:  BRA    0F12
.................... 			case G2_MOM: 
.................... 					// playback(SND_calling); 
.................... 					// blinkD2(2); 
.................... 					// event_GP2 = E_CALL_SENT; 
.................... 				break; 
0CA6:  BRA    0F12
.................... 			case G2_DAD: 
.................... 					// playback(SND_calling); 
.................... 					// blinkD2(2); 
.................... 					// event_GP2 = E_CALL_SENT; 
.................... 				break; 
0CA8:  BRA    0F12
.................... 			case G2_SON: 
.................... 					// playback(SND_calling); 
.................... 					// blinkD2(2); 
.................... 					// event_GP2 = E_CALL_SENT; 
.................... 				break; 
0CAA:  BRA    0F12
.................... 			case G2_DAUGHTER: 
.................... 					// playback(SND_calling); 
.................... 					// blinkD2(2); 
.................... 					// event_GP2 = E_CALL_SENT; 
.................... 				break; 
0CAC:  BRA    0F12
.................... 			case G2_ON: 
.................... 					// if (messages == G1_LIGHTS){ 
.................... 						// playback(SND_turning_on_light_bulb); 
.................... 						// output_high(PIN_D2); 
.................... 					// } 
.................... 					// else 
.................... 					// if (messages == G1_LED){ 
.................... 						// playback(SND_turning_on_LED); 
.................... 						// output_high(PIN_A1); 
.................... 					// } 
.................... 					// messages = 0; //clear messages 
.................... 					// event_GP2 = E_TASK_FINISHED; 
.................... 				break; 
0CAE:  BRA    0F12
.................... 			case G2_OFF: 
.................... 					// if (messages == G1_LIGHTS){ 
.................... 						// playback(SND_turning_off_light_bulb); 
.................... 						// output_low(PIN_D2); 
.................... 					// } 
.................... 					// else 
.................... 					// if (messages == G1_LED){ 
.................... 						// playback(SND_turning_off_LED); 
.................... 						// output_low(PIN_A1); 
.................... 					// } 
.................... 					// messages = 0; //clear messages 
.................... 					// event_GP2 = E_TASK_FINISHED; 
.................... 				break; 
0CB0:  BRA    0F12
.................... 			case G2_OTHER: 
.................... 					blinkD2(1); 
0CB2:  MOVLW  01
0CB4:  MOVWF  72
0CB6:  CALL   040A
.................... 					blinkD0(1); 
0CBA:  MOVLW  01
0CBC:  MOVWF  72
0CBE:  RCALL  0960
.................... 					fputs("ATD+18686822015;",GSM); 
0CC0:  MOVLW  50
0CC2:  MOVWF  FF6
0CC4:  MOVLW  02
0CC6:  MOVWF  FF7
0CC8:  CLRF   19
0CCA:  BTFSC  FF2.7
0CCC:  BSF    19.7
0CCE:  BCF    FF2.7
0CD0:  CALL   012A
0CD4:  BTFSC  19.7
0CD6:  BSF    FF2.7
0CD8:  CLRF   19
0CDA:  BTFSC  FF2.7
0CDC:  BSF    19.7
0CDE:  BCF    FF2.7
0CE0:  MOVLW  0D
0CE2:  MOVWF  7F
0CE4:  CALL   00EA
0CE8:  BTFSC  19.7
0CEA:  BSF    FF2.7
0CEC:  CLRF   19
0CEE:  BTFSC  FF2.7
0CF0:  BSF    19.7
0CF2:  BCF    FF2.7
0CF4:  MOVLW  0A
0CF6:  MOVWF  7F
0CF8:  CALL   00EA
0CFC:  BTFSC  19.7
0CFE:  BSF    FF2.7
.................... 					// event_GP2 = E_LIS_NUMS; 
.................... 					playback(SND_calling); 
0D00:  MOVLW  0E
0D02:  MOVWF  72
0D04:  CALL   042C
.................... 					for (count = 0; count == 6; count++){ 
0D08:  CLRF   69
0D0A:  MOVF   69,W
0D0C:  SUBLW  06
0D0E:  BTFSS  FD8.2
0D10:  BRA    0EB4
.................... 							// calling function to listen to group 3 
.................... 						listening_status = listenGP3(); 
0D12:  BRA    09AC
0D14:  MOVFF  01,65
.................... 						switch(listening_status){ 
0D18:  MOVF   65,W
0D1A:  XORLW  72
0D1C:  BZ    0D2C
0D1E:  XORLW  06
0D20:  BTFSC  FD8.2
0D22:  BRA    0EA2
0D24:  XORLW  11
0D26:  BTFSC  FD8.2
0D28:  BRA    0EAA
0D2A:  BRA    0EB0
.................... 							case STS_RESULT: 
.................... 							fputc(ARG_ACK,EVR); 
0D2C:  MOVLW  20
0D2E:  CALL   02DE
.................... 							ms25(); 
0D32:  CALL   030E
.................... 							receive = fgetc(EVR); 
0D36:  BTFSS  F9E.5
0D38:  BRA    0D36
0D3A:  MOVFF  FAE,67
.................... 							command_is = receive - ARG_ZERO; 
0D3E:  MOVLW  41
0D40:  SUBWF  67,W
0D42:  MOVWF  66
.................... 							switch (command_is){ 
0D44:  MOVF   66,W
0D46:  BZ    0D72
0D48:  XORLW  01
0D4A:  BZ    0D8E
0D4C:  XORLW  03
0D4E:  BZ    0DAA
0D50:  XORLW  01
0D52:  BZ    0DC6
0D54:  XORLW  07
0D56:  BZ    0DE2
0D58:  XORLW  01
0D5A:  BZ    0DFE
0D5C:  XORLW  03
0D5E:  BZ    0E1A
0D60:  XORLW  01
0D62:  BZ    0E36
0D64:  XORLW  0F
0D66:  BTFSC  FD8.2
0D68:  BRA    0E52
0D6A:  XORLW  01
0D6C:  BTFSC  FD8.2
0D6E:  BRA    0E6E
0D70:  BRA    0E8A
.................... 								case G3_ZERO: 
.................... 									playback(SND_zero); 
0D72:  MOVLW  01
0D74:  MOVWF  72
0D76:  CALL   042C
.................... 									ph_number[count] = 0x30;									 
0D7A:  CLRF   03
0D7C:  MOVF   69,W
0D7E:  ADDLW  6A
0D80:  MOVWF  FE9
0D82:  MOVLW  00
0D84:  ADDWFC 03,W
0D86:  MOVWF  FEA
0D88:  MOVLW  30
0D8A:  MOVWF  FEF
.................... 									break; 
0D8C:  BRA    0EA0
.................... 								case G3_ONE: 
.................... 									playback(SND_one); 
0D8E:  MOVLW  02
0D90:  MOVWF  72
0D92:  CALL   042C
.................... 									ph_number[count] = 0x31; 
0D96:  CLRF   03
0D98:  MOVF   69,W
0D9A:  ADDLW  6A
0D9C:  MOVWF  FE9
0D9E:  MOVLW  00
0DA0:  ADDWFC 03,W
0DA2:  MOVWF  FEA
0DA4:  MOVLW  31
0DA6:  MOVWF  FEF
.................... 									break; 
0DA8:  BRA    0EA0
.................... 								case G3_TWO: 
.................... 									playback(SND_two); 
0DAA:  MOVLW  03
0DAC:  MOVWF  72
0DAE:  CALL   042C
.................... 									ph_number[count] = 0x32; 
0DB2:  CLRF   03
0DB4:  MOVF   69,W
0DB6:  ADDLW  6A
0DB8:  MOVWF  FE9
0DBA:  MOVLW  00
0DBC:  ADDWFC 03,W
0DBE:  MOVWF  FEA
0DC0:  MOVLW  32
0DC2:  MOVWF  FEF
.................... 									break; 
0DC4:  BRA    0EA0
.................... 								case G3_THREE: 
.................... 									playback(SND_three); 
0DC6:  MOVLW  04
0DC8:  MOVWF  72
0DCA:  CALL   042C
.................... 									ph_number[count] = 0x33; 
0DCE:  CLRF   03
0DD0:  MOVF   69,W
0DD2:  ADDLW  6A
0DD4:  MOVWF  FE9
0DD6:  MOVLW  00
0DD8:  ADDWFC 03,W
0DDA:  MOVWF  FEA
0DDC:  MOVLW  33
0DDE:  MOVWF  FEF
.................... 									break; 
0DE0:  BRA    0EA0
.................... 								case G3_FOUR: 
.................... 									playback(SND_four); 
0DE2:  MOVLW  05
0DE4:  MOVWF  72
0DE6:  CALL   042C
.................... 									ph_number[count] = 0x34; 
0DEA:  CLRF   03
0DEC:  MOVF   69,W
0DEE:  ADDLW  6A
0DF0:  MOVWF  FE9
0DF2:  MOVLW  00
0DF4:  ADDWFC 03,W
0DF6:  MOVWF  FEA
0DF8:  MOVLW  34
0DFA:  MOVWF  FEF
.................... 									break; 
0DFC:  BRA    0EA0
.................... 								case G3_FIVE: 
.................... 									playback(SND_five); 
0DFE:  MOVLW  06
0E00:  MOVWF  72
0E02:  CALL   042C
.................... 									ph_number[count] = 0x35; 
0E06:  CLRF   03
0E08:  MOVF   69,W
0E0A:  ADDLW  6A
0E0C:  MOVWF  FE9
0E0E:  MOVLW  00
0E10:  ADDWFC 03,W
0E12:  MOVWF  FEA
0E14:  MOVLW  35
0E16:  MOVWF  FEF
.................... 									break; 
0E18:  BRA    0EA0
.................... 								case G3_SIX: 
.................... 									playback(SND_six); 
0E1A:  MOVLW  07
0E1C:  MOVWF  72
0E1E:  CALL   042C
.................... 									ph_number[count] = 0x36; 
0E22:  CLRF   03
0E24:  MOVF   69,W
0E26:  ADDLW  6A
0E28:  MOVWF  FE9
0E2A:  MOVLW  00
0E2C:  ADDWFC 03,W
0E2E:  MOVWF  FEA
0E30:  MOVLW  36
0E32:  MOVWF  FEF
.................... 									break; 
0E34:  BRA    0EA0
.................... 								case G3_SEVEN: 
.................... 									playback(SND_seven); 
0E36:  MOVLW  08
0E38:  MOVWF  72
0E3A:  CALL   042C
.................... 									ph_number[count] = 0x37; 
0E3E:  CLRF   03
0E40:  MOVF   69,W
0E42:  ADDLW  6A
0E44:  MOVWF  FE9
0E46:  MOVLW  00
0E48:  ADDWFC 03,W
0E4A:  MOVWF  FEA
0E4C:  MOVLW  37
0E4E:  MOVWF  FEF
.................... 									break; 
0E50:  BRA    0EA0
.................... 								case G3_EIGHT: 
.................... 									playback(SND_eight); 
0E52:  MOVLW  09
0E54:  MOVWF  72
0E56:  CALL   042C
.................... 									ph_number[count] = 0x38; 
0E5A:  CLRF   03
0E5C:  MOVF   69,W
0E5E:  ADDLW  6A
0E60:  MOVWF  FE9
0E62:  MOVLW  00
0E64:  ADDWFC 03,W
0E66:  MOVWF  FEA
0E68:  MOVLW  38
0E6A:  MOVWF  FEF
.................... 									break; 
0E6C:  BRA    0EA0
.................... 								case G3_NINE: 
.................... 									playback(SND_nine); 
0E6E:  MOVLW  0A
0E70:  MOVWF  72
0E72:  CALL   042C
.................... 									ph_number[count] = 0x39; 
0E76:  CLRF   03
0E78:  MOVF   69,W
0E7A:  ADDLW  6A
0E7C:  MOVWF  FE9
0E7E:  MOVLW  00
0E80:  ADDWFC 03,W
0E82:  MOVWF  FEA
0E84:  MOVLW  39
0E86:  MOVWF  FEF
.................... 									break; 
0E88:  BRA    0EA0
.................... 								default: 
.................... 									blinkD0(4); 
0E8A:  MOVLW  04
0E8C:  MOVWF  72
0E8E:  RCALL  0960
.................... 									ph_number[count] = 0x00; 
0E90:  CLRF   03
0E92:  MOVF   69,W
0E94:  ADDLW  6A
0E96:  MOVWF  FE9
0E98:  MOVLW  00
0E9A:  ADDWFC 03,W
0E9C:  MOVWF  FEA
0E9E:  CLRF   FEF
.................... 									break; 
.................... 							} 
.................... 							break; 
0EA0:  BRA    0EB0
.................... 							case STS_TIMEOUT: 
.................... 								blinkD0(2); 
0EA2:  MOVLW  02
0EA4:  MOVWF  72
0EA6:  RCALL  0960
.................... 							break; 
0EA8:  BRA    0EB0
.................... 							case STS_ERROR: 
.................... 								blinkD0(3); 
0EAA:  MOVLW  03
0EAC:  MOVWF  72
0EAE:  RCALL  0960
.................... 							break; 
.................... 						}//end of listening to commands 
0EB0:  INCF   69,F
0EB2:  BRA    0D0A
.................... 					} 
.................... 					ph_number[7] = 0x00; //add the null character 
0EB4:  CLRF   71
.................... 					strcat(dial,ph_number); 
0EB6:  CLRF   73
0EB8:  MOVLW  4D
0EBA:  MOVWF  72
0EBC:  CLRF   75
0EBE:  MOVLW  6A
0EC0:  MOVWF  74
0EC2:  RCALL  09D6
.................... 					strcat(dial,end); 
0EC4:  CLRF   73
0EC6:  MOVLW  4D
0EC8:  MOVWF  72
0ECA:  CLRF   75
0ECC:  MOVLW  61
0ECE:  MOVWF  74
0ED0:  RCALL  09D6
.................... 					fputs(dial,GSM); 
0ED2:  CLRF   FEA
0ED4:  MOVLW  4D
0ED6:  MOVWF  FE9
0ED8:  CALL   0262
0EDC:  CLRF   19
0EDE:  BTFSC  FF2.7
0EE0:  BSF    19.7
0EE2:  BCF    FF2.7
0EE4:  MOVLW  0D
0EE6:  MOVWF  7F
0EE8:  CALL   00EA
0EEC:  BTFSC  19.7
0EEE:  BSF    FF2.7
0EF0:  CLRF   19
0EF2:  BTFSC  FF2.7
0EF4:  BSF    19.7
0EF6:  BCF    FF2.7
0EF8:  MOVLW  0A
0EFA:  MOVWF  7F
0EFC:  CALL   00EA
0F00:  BTFSC  19.7
0F02:  BSF    FF2.7
.................... 					count = 0; 
0F04:  CLRF   69
.................... 					test = STATE1; 
0F06:  CLRF   68
.................... 				break; 
0F08:  BRA    0F12
.................... 			default: 
.................... 					blinkD2(4); 
0F0A:  MOVLW  04
0F0C:  MOVWF  72
0F0E:  CALL   040A
.................... 					// event_GP2 = E_TASK_FINISHED; 
.................... 				break; 
.................... 		} 
.................... 		break; 
0F12:  BRA    0F26
.................... 		case STS_TIMEOUT: 
.................... 			blinkD2(2); 
0F14:  MOVLW  02
0F16:  MOVWF  72
0F18:  CALL   040A
.................... 		break; 
0F1C:  BRA    0F26
.................... 		case STS_ERROR: 
.................... 			blinkD2(3); 
0F1E:  MOVLW  03
0F20:  MOVWF  72
0F22:  CALL   040A
.................... 		break; 
.................... 	} 
.................... } 
0F26:  BRA    0B34
.................... //end of third state 
.................... }//end of while(TRUE) loop 
....................  
.................... }//<<end of MAIN FUNCTION 
0F28:  BRA    0F28

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
